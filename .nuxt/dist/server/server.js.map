{"version":3,"file":"server.js","sources":["webpack:///webpack/bootstrap","webpack:///./.nuxt/nuxt-i18n/options.js","webpack:///external \"vue\"","webpack:///./.nuxt/nuxt-i18n/utils-common.js","webpack:///./node_modules/ufo/dist/index.cjs","webpack:///./node_modules/@nuxt/image/node_modules/ufo/dist/index.cjs","webpack:///./node_modules/vue-loader/lib/runtime/componentNormalizer.js","webpack:///./node_modules/@nuxtjs/i18n/node_modules/ufo/dist/index.cjs","webpack:///external \"vue-meta\"","webpack:///external \"axios\"","webpack:///external \"url\"","webpack:///external \"vue-no-ssr\"","webpack:///external \"cookie\"","webpack:///external \"vue-client-only\"","webpack:///external \"vue-router\"","webpack:///external \"vue-i18n\"","webpack:///./node_modules/@nuxt/image/node_modules/defu/dist/defu.cjs","webpack:///./.nuxt/components/nuxt-loading.vue?bb95","webpack:///external \"node-fetch-native\"","webpack:///./node_modules/is-https/dist/index.js","webpack:///./.nuxt/nuxt-i18n/head-meta.js","webpack:///./node_modules/defu/dist/defu.cjs","webpack:///./node_modules/@nuxt/components/lib/installComponents.js","webpack:///./.nuxt/components/nuxt-loading.vue?a5cc","webpack:///./node_modules/vuetify/src/styles/main.sass","webpack:///external \"js-cookie\"","webpack:///external \"core-js/modules/esnext.map.delete-all.js\"","webpack:///external \"core-js/modules/esnext.map.every.js\"","webpack:///external \"core-js/modules/esnext.map.filter.js\"","webpack:///external \"core-js/modules/esnext.map.find.js\"","webpack:///external \"core-js/modules/esnext.map.find-key.js\"","webpack:///external \"core-js/modules/esnext.map.includes.js\"","webpack:///external \"core-js/modules/esnext.map.key-of.js\"","webpack:///external \"core-js/modules/esnext.map.map-keys.js\"","webpack:///external \"core-js/modules/esnext.map.map-values.js\"","webpack:///external \"core-js/modules/esnext.map.merge.js\"","webpack:///external \"core-js/modules/esnext.map.reduce.js\"","webpack:///external \"core-js/modules/esnext.map.some.js\"","webpack:///external \"core-js/modules/esnext.map.update.js\"","webpack:///./.nuxt/middleware.js","webpack:///./.nuxt/utils.js","webpack:///./.nuxt/mixins/fetch.server.js","webpack:///./.nuxt/router.scrollBehavior.js","webpack:///./.nuxt/router.js","webpack:///./.nuxt/components/nuxt-child.js","webpack:///./layouts/error.vue","webpack:///./layouts/error.vue?a34c","webpack:///./layouts/error.vue?4aaa","webpack:///./.nuxt/components/nuxt.js","webpack:///./.nuxt/components/nuxt-loading.vue","webpack:///./.nuxt/components/nuxt-loading.vue?bcea","webpack:///./.nuxt/components/nuxt-loading.vue?f2ce","webpack:///./layouts/default.vue","webpack:///./layouts/default.vue?8116","webpack:///./layouts/default.vue?7e9a","webpack:///./.nuxt/App.js","webpack:///./.nuxt/components/index.js","webpack:///./.nuxt/components/plugin.js","webpack:///../../src/util/console.ts","webpack:///../src/install.ts","webpack:///../../src/locale/en.ts","webpack:///../../../src/presets/default/index.ts","webpack:///../../src/util/helpers.ts","webpack:///../../../src/services/service/index.ts","webpack:///../../../src/services/presets/index.ts","webpack:///../../../src/services/application/index.ts","webpack:///../../../src/services/breakpoint/index.ts","webpack:///../../../src/services/goto/easing-patterns.ts","webpack:///../../../src/services/goto/util.ts","webpack:///../../../src/services/goto/index.ts","webpack:///../../../../src/services/icons/presets/mdi-svg.ts","webpack:///../../../../src/services/icons/presets/md.ts","webpack:///../../../../src/services/icons/presets/mdi.ts","webpack:///../../../../src/services/icons/presets/fa.ts","webpack:///../../../../src/services/icons/presets/fa4.ts","webpack:///../../../../src/services/icons/presets/fa-svg.ts","webpack:///../../../../src/services/icons/presets/index.ts","webpack:///../../../src/services/icons/index.ts","webpack:///../../../src/services/lang/index.ts","webpack:///../../../src/util/color/transformSRGB.ts","webpack:///../../src/util/colorUtils.ts","webpack:///../../../src/util/color/transformCIELAB.ts","webpack:///../../../src/services/theme/utils.ts","webpack:///../../../src/services/theme/index.ts","webpack:///../src/framework.ts","webpack:///./.nuxt/vuetify/options.js","webpack:///./.nuxt/vuetify/plugin.js","webpack:///./.nuxt/nuxt-i18n/plugin.utils.js","webpack:///./.nuxt/nuxt-i18n/middleware.js","webpack:///./.nuxt/nuxt-i18n/plugin.routing.js","webpack:///./node_modules/klona/full/index.mjs","webpack:///./.nuxt/nuxt-i18n/plugin.main.js","webpack:///./.nuxt/axios.js","webpack:///./node_modules/@nuxt/image/dist/runtime/utils/meta.js","webpack:///./node_modules/@nuxt/image/dist/runtime/utils/index.js","webpack:///./node_modules/@nuxt/image/dist/runtime/image.js","webpack:///./node_modules/@nuxt/image/dist/runtime/components/nuxt-img.vue","webpack:///./node_modules/@nuxt/image/dist/runtime/components/image.mixin.js","webpack:///./node_modules/@nuxt/image/dist/runtime/components/nuxt-img.vue?933c","webpack:///./node_modules/@nuxt/image/dist/runtime/components/nuxt-img.vue?6c92","webpack:///./node_modules/@nuxt/image/dist/runtime/components/nuxt-picture.vue","webpack:///./node_modules/@nuxt/image/dist/runtime/components/nuxt-picture.vue?05a4","webpack:///./node_modules/@nuxt/image/dist/runtime/components/nuxt-picture.vue?8aea","webpack:///./node_modules/@nuxt/image/dist/runtime/providers/ipx.js","webpack:///./node_modules/@nuxt/image/dist/runtime/providers/static.js","webpack:///./.nuxt/image.js","webpack:///./.nuxt/index.js","webpack:///./.nuxt/components/nuxt-link.server.js","webpack:///./.nuxt/server.js","webpack:///external \"devalue\"","webpack:///external \"image-meta\""],"sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// object to store loaded chunks\n \t// \"0\" means \"already loaded\"\n \tvar installedChunks = {\n \t\t0: 0\n \t};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n \t// This file contains only the entry chunk.\n \t// The chunk loading function for additional chunks\n \t__webpack_require__.e = function requireEnsure(chunkId) {\n \t\tvar promises = [];\n\n\n \t\t// require() chunk loading for javascript\n\n \t\t// \"0\" is the signal for \"already loaded\"\n \t\tif(installedChunks[chunkId] !== 0) {\n \t\t\tvar chunk = require(\"./\" + ({\"1\":\"components/nuxt-logo\",\"2\":\"components/tutorial\",\"3\":\"components/vuetify-logo\",\"4\":\"pages/index\",\"5\":\"pages/inspire\"}[chunkId]||chunkId) + \".js\");\n \t\t\tvar moreModules = chunk.modules, chunkIds = chunk.ids;\n \t\t\tfor(var moduleId in moreModules) {\n \t\t\t\tmodules[moduleId] = moreModules[moduleId];\n \t\t\t}\n \t\t\tfor(var i = 0; i < chunkIds.length; i++)\n \t\t\t\tinstalledChunks[chunkIds[i]] = 0;\n \t\t}\n \t\treturn Promise.all(promises);\n \t};\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/_nuxt/\";\n\n \t// uncaught error handler for webpack runtime\n \t__webpack_require__.oe = function(err) {\n \t\tprocess.nextTick(function() {\n \t\t\tthrow err; // catch this error by using import().catch()\n \t\t});\n \t};\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 22);\n","export const Constants = {\n  COMPONENT_OPTIONS_KEY: \"nuxtI18n\",\n  STRATEGIES: {\"PREFIX\":\"prefix\",\"PREFIX_EXCEPT_DEFAULT\":\"prefix_except_default\",\"PREFIX_AND_DEFAULT\":\"prefix_and_default\",\"NO_PREFIX\":\"no_prefix\"},\n  REDIRECT_ON_OPTIONS: {\"ALL\":\"all\",\"ROOT\":\"root\",\"NO_PREFIX\":\"no prefix\"},\n}\nexport const nuxtOptions = {\n  isUniversalMode: true,\n  trailingSlash: undefined,\n}\nexport const options = {\n  vueI18n: {},\n  vueI18nLoader: false,\n  locales: [],\n  defaultLocale: \"\",\n  defaultDirection: \"ltr\",\n  routesNameSeparator: \"___\",\n  defaultLocaleRouteNameSuffix: \"default\",\n  sortRoutes: true,\n  strategy: \"prefix_except_default\",\n  lazy: false,\n  langDir: null,\n  rootRedirect: null,\n  detectBrowserLanguage: {\"alwaysRedirect\":false,\"cookieAge\":365,\"cookieCrossOrigin\":false,\"cookieDomain\":null,\"cookieKey\":\"i18n_redirected\",\"cookieSecure\":false,\"fallbackLocale\":\"\",\"redirectOn\":\"root\",\"useCookie\":true},\n  differentDomains: false,\n  baseUrl: \"\",\n  vuex: {\"moduleName\":\"i18n\",\"syncRouteParams\":true},\n  parsePages: true,\n  pages: {},\n  skipSettingLocaleOnNavigate: false,\n  onBeforeLanguageSwitch: () => {},\n  onLanguageSwitched: () => null,\n  normalizedLocales: [],\n  localeCodes: [],\n  additionalMessages: [],\n}\nexport const localeFiles = {\n  0: \"{\",\n  1: \"}\",\n}\n\nexport const localeMessages = {}\n","module.exports = require(\"vue\");","import { parse as cookieParse, serialize as cookieSerialize } from 'cookie'\nimport JsCookie from 'js-cookie'\n\n/**\n * @typedef {import('../../types/internal').ResolvedOptions} ResolvedOptions\n * @typedef {Required<import('../../types/').DetectBrowserLanguageOptions>} DetectBrowserLanguageOptions\n */\n\n/**\n * Formats a log message, prefixing module's name to it.\n *\n * @param {string} text\n * @return {string}\n */\nexport function formatMessage (text) {\n  return `[@nuxtjs/i18n] ${text}`\n}\n\n/**\n * Parses locales provided from browser through `accept-language` header.\n *\n * @param {string} input\n * @return {string[]} An array of locale codes. Priority determined by order in array.\n */\nexport function parseAcceptLanguage (input) {\n  // Example input: en-US,en;q=0.9,nb;q=0.8,no;q=0.7\n  // Contains tags separated by comma.\n  // Each tag consists of locale code (2-3 letter language code) and optionally country code\n  // after dash. Tag can also contain score after semicolon, that is assumed to match order\n  // so it's not explicitly used.\n  return input.split(',').map(tag => tag.split(';')[0])\n}\n\n/**\n * Find locale code that best matches provided list of browser locales.\n *\n * @param {ResolvedOptions['normalizedLocales']} appLocales The user-configured locales that are to be matched.\n * @param {readonly string[]} browserLocales The locales to match against configured.\n * @return {string | undefined}\n */\nexport function matchBrowserLocale (appLocales, browserLocales) {\n  /** @type {{ code: string, score: number }[]} */\n  const matchedLocales = []\n\n  // Normalise appLocales input\n  /** @type {{ code: string, iso: string }[]} */\n  const normalizedAppLocales = []\n  for (const appLocale of appLocales) {\n    const { code } = appLocale\n    const iso = appLocale.iso || code\n    normalizedAppLocales.push({ code, iso })\n  }\n\n  // First pass: match exact locale.\n  for (const [index, browserCode] of browserLocales.entries()) {\n    const matchedLocale = normalizedAppLocales.find(appLocale => appLocale.iso.toLowerCase() === browserCode.toLowerCase())\n    if (matchedLocale) {\n      matchedLocales.push({ code: matchedLocale.code, score: 1 - index / browserLocales.length })\n      break\n    }\n  }\n\n  // Second pass: match only locale code part of the browser locale (not including country).\n  for (const [index, browserCode] of browserLocales.entries()) {\n    const languageCode = browserCode.split('-')[0].toLowerCase()\n    const matchedLocale = normalizedAppLocales.find(appLocale => appLocale.iso.split('-')[0].toLowerCase() === languageCode)\n    if (matchedLocale) {\n      // Deduct a thousandth for being non-exact match.\n      matchedLocales.push({ code: matchedLocale.code, score: 0.999 - index / browserLocales.length })\n      break\n    }\n  }\n\n  // Sort the list by score (0 - lowest, 1 - highest).\n  if (matchedLocales.length > 1) {\n    matchedLocales.sort((localeA, localeB) => {\n      if (localeA.score === localeB.score) {\n        // If scores are equal then pick more specific (longer) code.\n        return localeB.code.length - localeA.code.length\n      }\n\n      return localeB.score - localeA.score\n    })\n  }\n\n  return matchedLocales.length ? matchedLocales[0].code : undefined\n}\n\n/**\n * Get locale code that corresponds to current hostname\n *\n * @param  {ResolvedOptions['normalizedLocales']} locales\n * @param  {import('http').IncomingMessage | undefined} req\n * @return {string} Locale code found if any\n */\nexport function getLocaleDomain (locales, req) {\n  /** @type {string | undefined} */\n  let host\n\n  if (process.client) {\n    host = window.location.host\n  } else if (req) {\n    const detectedHost = req.headers['x-forwarded-host'] || req.headers.host\n    host = Array.isArray(detectedHost) ? detectedHost[0] : detectedHost\n  }\n\n  if (host) {\n    const matchingLocale = locales.find(l => l.domain === host)\n    if (matchingLocale) {\n      return matchingLocale.code\n    }\n  }\n\n  return ''\n}\n\n/**\n * Creates a RegExp for route paths\n *\n * @param  {readonly string[]} localeCodes\n * @return {RegExp}\n */\nexport function getLocalesRegex (localeCodes) {\n  return new RegExp(`^/(${localeCodes.join('|')})(?:/|$)`)\n}\n\n/**\n * Creates getter for getLocaleFromRoute\n *\n * @param  {readonly string[]} localeCodes\n * @param  {Pick<ResolvedOptions, 'routesNameSeparator' | 'defaultLocaleRouteNameSuffix'>} options\n */\nexport function createLocaleFromRouteGetter (localeCodes, { routesNameSeparator, defaultLocaleRouteNameSuffix }) {\n  const localesPattern = `(${localeCodes.join('|')})`\n  const defaultSuffixPattern = `(?:${routesNameSeparator}${defaultLocaleRouteNameSuffix})?`\n  const regexpName = new RegExp(`${routesNameSeparator}${localesPattern}${defaultSuffixPattern}$`)\n  const regexpPath = getLocalesRegex(localeCodes)\n  /**\n   * Extract locale code from given route:\n   * - If route has a name, try to extract locale from it\n   * - Otherwise, fall back to using the routes'path\n   * @param  {import('vue-router').Route} route\n   * @return {string} Locale code found if any\n   */\n  const getLocaleFromRoute = route => {\n    // Extract from route name\n    if (route.name) {\n      const matches = route.name.match(regexpName)\n      if (matches && matches.length > 1) {\n        return matches[1]\n      }\n    } else if (route.path) {\n      // Extract from path\n      const matches = route.path.match(regexpPath)\n      if (matches && matches.length > 1) {\n        return matches[1]\n      }\n    }\n\n    return ''\n  }\n\n  return getLocaleFromRoute\n}\n\n/**\n * @param {import('http').IncomingMessage | undefined} req\n * @param {{ useCookie: boolean, cookieKey: string, localeCodes: readonly string[] }} options\n * @return {string | undefined}\n */\nexport function getLocaleCookie (req, { useCookie, cookieKey, localeCodes }) {\n  if (useCookie) {\n    let localeCode\n\n    if (process.client) {\n      localeCode = JsCookie.get(cookieKey)\n    } else if (req && typeof req.headers.cookie !== 'undefined') {\n      const cookies = req.headers && req.headers.cookie ? cookieParse(req.headers.cookie) : {}\n      localeCode = cookies[cookieKey]\n    }\n\n    if (localeCode && localeCodes.includes(localeCode)) {\n      return localeCode\n    }\n  }\n}\n\n/**\n * @param {string} locale\n * @param {import('http').ServerResponse | undefined} res\n * @param {Pick<DetectBrowserLanguageOptions, 'useCookie' | 'cookieAge' | 'cookieDomain' | 'cookieKey' | 'cookieSecure' | 'cookieCrossOrigin'>} options\n */\nexport function setLocaleCookie (locale, res, { useCookie, cookieAge, cookieDomain, cookieKey, cookieSecure, cookieCrossOrigin }) {\n  if (!useCookie) {\n    return\n  }\n  if (process.client) {\n    /** @type {import('js-cookie').CookieAttributes} */\n    const cookieOptions = {\n      expires: cookieAge,\n      path: '/',\n      sameSite: cookieCrossOrigin ? 'none' : 'lax',\n      secure: cookieCrossOrigin || cookieSecure,\n      ...cookieDomain ? { domain: cookieDomain } : {}\n    }\n    JsCookie.set(cookieKey, locale, cookieOptions)\n  } else if (res) {\n    let headers = res.getHeader('Set-Cookie') || []\n    if (!Array.isArray(headers)) {\n      headers = [String(headers)]\n    }\n\n    /** @type {import('cookie').CookieSerializeOptions} */\n    const cookieOptions = {\n      maxAge: cookieAge * 60 * 60 * 24, // in seconds\n      path: '/',\n      sameSite: cookieCrossOrigin ? 'none' : 'lax',\n      secure: cookieCrossOrigin || cookieSecure,\n      ...cookieDomain ? { domain: cookieDomain } : {}\n    }\n    const redirectCookie = cookieSerialize(cookieKey, locale, cookieOptions)\n    headers = headers.filter(header => {\n      const cookie = cookieParse(header)\n      return !(cookieKey in cookie)\n    })\n    headers.push(redirectCookie)\n\n    res.setHeader('Set-Cookie', headers)\n  }\n}\n","'use strict';\n\nconst n = /[^\\0-\\x7E]/;\nconst t = /[\\x2E\\u3002\\uFF0E\\uFF61]/g;\nconst o = {\n  overflow: \"Overflow Error\",\n  \"not-basic\": \"Illegal Input\",\n  \"invalid-input\": \"Invalid Input\"\n};\nconst e = Math.floor;\nconst r = String.fromCharCode;\nfunction s(n2) {\n  throw new RangeError(o[n2]);\n}\nconst c = function(n2, t2) {\n  return n2 + 22 + 75 * (n2 < 26) - ((t2 != 0) << 5);\n};\nconst u = function(n2, t2, o2) {\n  let r2 = 0;\n  for (n2 = o2 ? e(n2 / 700) : n2 >> 1, n2 += e(n2 / t2); n2 > 455; r2 += 36) {\n    n2 = e(n2 / 35);\n  }\n  return e(r2 + 36 * n2 / (n2 + 38));\n};\nfunction toASCII(o2) {\n  return function(n2, o3) {\n    const e2 = n2.split(\"@\");\n    let r2 = \"\";\n    e2.length > 1 && (r2 = e2[0] + \"@\", n2 = e2[1]);\n    const s2 = function(n3, t2) {\n      const o4 = [];\n      let e3 = n3.length;\n      for (; e3--; ) {\n        o4[e3] = t2(n3[e3]);\n      }\n      return o4;\n    }((n2 = n2.replace(t, \".\")).split(\".\"), o3).join(\".\");\n    return r2 + s2;\n  }(o2, function(t2) {\n    return n.test(t2) ? \"xn--\" + function(n2) {\n      const t3 = [];\n      const o3 = (n2 = function(n3) {\n        const t4 = [];\n        let o4 = 0;\n        const e2 = n3.length;\n        for (; o4 < e2; ) {\n          const r2 = n3.charCodeAt(o4++);\n          if (r2 >= 55296 && r2 <= 56319 && o4 < e2) {\n            const e3 = n3.charCodeAt(o4++);\n            (64512 & e3) == 56320 ? t4.push(((1023 & r2) << 10) + (1023 & e3) + 65536) : (t4.push(r2), o4--);\n          } else {\n            t4.push(r2);\n          }\n        }\n        return t4;\n      }(n2)).length;\n      let f = 128;\n      let i = 0;\n      let l = 72;\n      for (const o4 of n2) {\n        o4 < 128 && t3.push(r(o4));\n      }\n      const h = t3.length;\n      let p = h;\n      for (h && t3.push(\"-\"); p < o3; ) {\n        let o4 = 2147483647;\n        for (const t4 of n2) {\n          t4 >= f && t4 < o4 && (o4 = t4);\n        }\n        const a = p + 1;\n        o4 - f > e((2147483647 - i) / a) && s(\"overflow\"), i += (o4 - f) * a, f = o4;\n        for (const o5 of n2) {\n          if (o5 < f && ++i > 2147483647 && s(\"overflow\"), o5 == f) {\n            let n3 = i;\n            for (let o6 = 36; ; o6 += 36) {\n              const s2 = o6 <= l ? 1 : o6 >= l + 26 ? 26 : o6 - l;\n              if (n3 < s2) {\n                break;\n              }\n              const u2 = n3 - s2;\n              const f2 = 36 - s2;\n              t3.push(r(c(s2 + u2 % f2, 0))), n3 = e(u2 / f2);\n            }\n            t3.push(r(c(n3, 0))), l = u(i, a, p == h), i = 0, ++p;\n          }\n        }\n        ++i, ++f;\n      }\n      return t3.join(\"\");\n    }(t2) : t2;\n  });\n}\n\nconst HASH_RE = /#/g;\nconst AMPERSAND_RE = /&/g;\nconst SLASH_RE = /\\//g;\nconst EQUAL_RE = /=/g;\nconst IM_RE = /\\?/g;\nconst PLUS_RE = /\\+/g;\nconst ENC_CARET_RE = /%5e/gi;\nconst ENC_BACKTICK_RE = /%60/gi;\nconst ENC_CURLY_OPEN_RE = /%7b/gi;\nconst ENC_PIPE_RE = /%7c/gi;\nconst ENC_CURLY_CLOSE_RE = /%7d/gi;\nconst ENC_SPACE_RE = /%20/gi;\nconst ENC_SLASH_RE = /%2f/gi;\nconst ENC_ENC_SLASH_RE = /%252f/gi;\nfunction encode(text) {\n  return encodeURI(\"\" + text).replace(ENC_PIPE_RE, \"|\");\n}\nfunction encodeHash(text) {\n  return encode(text).replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryValue(input) {\n  return encode(typeof input === \"string\" ? input : JSON.stringify(input)).replace(PLUS_RE, \"%2B\").replace(ENC_SPACE_RE, \"+\").replace(HASH_RE, \"%23\").replace(AMPERSAND_RE, \"%26\").replace(ENC_BACKTICK_RE, \"`\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryKey(text) {\n  return encodeQueryValue(text).replace(EQUAL_RE, \"%3D\");\n}\nfunction encodePath(text) {\n  return encode(text).replace(HASH_RE, \"%23\").replace(IM_RE, \"%3F\").replace(ENC_ENC_SLASH_RE, \"%2F\").replace(AMPERSAND_RE, \"%26\").replace(PLUS_RE, \"%2B\");\n}\nfunction encodeParam(text) {\n  return encodePath(text).replace(SLASH_RE, \"%2F\");\n}\nfunction decode(text = \"\") {\n  try {\n    return decodeURIComponent(\"\" + text);\n  } catch {\n    return \"\" + text;\n  }\n}\nfunction decodePath(text) {\n  return decode(text.replace(ENC_SLASH_RE, \"%252F\"));\n}\nfunction decodeQueryValue(text) {\n  return decode(text.replace(PLUS_RE, \" \"));\n}\nfunction encodeHost(name = \"\") {\n  return toASCII(name);\n}\n\nfunction parseQuery(parametersString = \"\") {\n  const object = {};\n  if (parametersString[0] === \"?\") {\n    parametersString = parametersString.slice(1);\n  }\n  for (const parameter of parametersString.split(\"&\")) {\n    const s = parameter.match(/([^=]+)=?(.*)/) || [];\n    if (s.length < 2) {\n      continue;\n    }\n    const key = decode(s[1]);\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = decodeQueryValue(s[2] || \"\");\n    if (typeof object[key] !== \"undefined\") {\n      if (Array.isArray(object[key])) {\n        object[key].push(value);\n      } else {\n        object[key] = [object[key], value];\n      }\n    } else {\n      object[key] = value;\n    }\n  }\n  return object;\n}\nfunction encodeQueryItem(key, value) {\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    value = String(value);\n  }\n  if (!value) {\n    return encodeQueryKey(key);\n  }\n  if (Array.isArray(value)) {\n    return value.map((_value) => `${encodeQueryKey(key)}=${encodeQueryValue(_value)}`).join(\"&\");\n  }\n  return `${encodeQueryKey(key)}=${encodeQueryValue(value)}`;\n}\nfunction stringifyQuery(query) {\n  return Object.keys(query).filter((k) => query[k] !== void 0).map((k) => encodeQueryItem(k, query[k])).join(\"&\");\n}\n\nclass $URL {\n  constructor(input = \"\") {\n    this.query = {};\n    if (typeof input !== \"string\") {\n      throw new TypeError(\n        `URL input should be string received ${typeof input} (${input})`\n      );\n    }\n    const parsed = parseURL(input);\n    this.protocol = decode(parsed.protocol);\n    this.host = decode(parsed.host);\n    this.auth = decode(parsed.auth);\n    this.pathname = decodePath(parsed.pathname);\n    this.query = parseQuery(parsed.search);\n    this.hash = decode(parsed.hash);\n  }\n  get hostname() {\n    return parseHost(this.host).hostname;\n  }\n  get port() {\n    return parseHost(this.host).port || \"\";\n  }\n  get username() {\n    return parseAuth(this.auth).username;\n  }\n  get password() {\n    return parseAuth(this.auth).password || \"\";\n  }\n  get hasProtocol() {\n    return this.protocol.length;\n  }\n  get isAbsolute() {\n    return this.hasProtocol || this.pathname[0] === \"/\";\n  }\n  get search() {\n    const q = stringifyQuery(this.query);\n    return q.length > 0 ? \"?\" + q : \"\";\n  }\n  get searchParams() {\n    const p = new URLSearchParams();\n    for (const name in this.query) {\n      const value = this.query[name];\n      if (Array.isArray(value)) {\n        for (const v of value) {\n          p.append(name, v);\n        }\n      } else {\n        p.append(\n          name,\n          typeof value === \"string\" ? value : JSON.stringify(value)\n        );\n      }\n    }\n    return p;\n  }\n  get origin() {\n    return (this.protocol ? this.protocol + \"//\" : \"\") + encodeHost(this.host);\n  }\n  get fullpath() {\n    return encodePath(this.pathname) + this.search + encodeHash(this.hash);\n  }\n  get encodedAuth() {\n    if (!this.auth) {\n      return \"\";\n    }\n    const { username, password } = parseAuth(this.auth);\n    return encodeURIComponent(username) + (password ? \":\" + encodeURIComponent(password) : \"\");\n  }\n  get href() {\n    const auth = this.encodedAuth;\n    const originWithAuth = (this.protocol ? this.protocol + \"//\" : \"\") + (auth ? auth + \"@\" : \"\") + encodeHost(this.host);\n    return this.hasProtocol && this.isAbsolute ? originWithAuth + this.fullpath : this.fullpath;\n  }\n  append(url) {\n    if (url.hasProtocol) {\n      throw new Error(\"Cannot append a URL with protocol\");\n    }\n    Object.assign(this.query, url.query);\n    if (url.pathname) {\n      this.pathname = withTrailingSlash(this.pathname) + withoutLeadingSlash(url.pathname);\n    }\n    if (url.hash) {\n      this.hash = url.hash;\n    }\n  }\n  toJSON() {\n    return this.href;\n  }\n  toString() {\n    return this.href;\n  }\n}\n\nfunction isRelative(inputString) {\n  return [\"./\", \"../\"].some((string_) => inputString.startsWith(string_));\n}\nconst PROTOCOL_STRICT_REGEX = /^\\w{2,}:([/\\\\]{1,2})/;\nconst PROTOCOL_REGEX = /^\\w{2,}:([/\\\\]{2})?/;\nconst PROTOCOL_RELATIVE_REGEX = /^[/\\\\]{2}[^/\\\\]+/;\nfunction hasProtocol(inputString, opts = {}) {\n  if (typeof opts === \"boolean\") {\n    opts = { acceptRelative: opts };\n  }\n  if (opts.strict) {\n    return PROTOCOL_STRICT_REGEX.test(inputString);\n  }\n  return PROTOCOL_REGEX.test(inputString) || (opts.acceptRelative ? PROTOCOL_RELATIVE_REGEX.test(inputString) : false);\n}\nconst TRAILING_SLASH_RE = /\\/$|\\/\\?/;\nfunction hasTrailingSlash(input = \"\", queryParameters = false) {\n  if (!queryParameters) {\n    return input.endsWith(\"/\");\n  }\n  return TRAILING_SLASH_RE.test(input);\n}\nfunction withoutTrailingSlash(input = \"\", queryParameters = false) {\n  if (!queryParameters) {\n    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || \"/\";\n  }\n  if (!hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  const [s0, ...s] = input.split(\"?\");\n  return (s0.slice(0, -1) || \"/\") + (s.length > 0 ? `?${s.join(\"?\")}` : \"\");\n}\nfunction withTrailingSlash(input = \"\", queryParameters = false) {\n  if (!queryParameters) {\n    return input.endsWith(\"/\") ? input : input + \"/\";\n  }\n  if (hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  const [s0, ...s] = input.split(\"?\");\n  return s0 + \"/\" + (s.length > 0 ? `?${s.join(\"?\")}` : \"\");\n}\nfunction hasLeadingSlash(input = \"\") {\n  return input.startsWith(\"/\");\n}\nfunction withoutLeadingSlash(input = \"\") {\n  return (hasLeadingSlash(input) ? input.slice(1) : input) || \"/\";\n}\nfunction withLeadingSlash(input = \"\") {\n  return hasLeadingSlash(input) ? input : \"/\" + input;\n}\nfunction cleanDoubleSlashes(input = \"\") {\n  return input.split(\"://\").map((string_) => string_.replace(/\\/{2,}/g, \"/\")).join(\"://\");\n}\nfunction withBase(input, base) {\n  if (isEmptyURL(base) || hasProtocol(input)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (input.startsWith(_base)) {\n    return input;\n  }\n  return joinURL(_base, input);\n}\nfunction withoutBase(input, base) {\n  if (isEmptyURL(base)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (!input.startsWith(_base)) {\n    return input;\n  }\n  const trimmed = input.slice(_base.length);\n  return trimmed[0] === \"/\" ? trimmed : \"/\" + trimmed;\n}\nfunction withQuery(input, query) {\n  const parsed = parseURL(input);\n  const mergedQuery = { ...parseQuery(parsed.search), ...query };\n  parsed.search = stringifyQuery(mergedQuery);\n  return stringifyParsedURL(parsed);\n}\nfunction getQuery(input) {\n  return parseQuery(parseURL(input).search);\n}\nfunction isEmptyURL(url) {\n  return !url || url === \"/\";\n}\nfunction isNonEmptyURL(url) {\n  return url && url !== \"/\";\n}\nfunction joinURL(base, ...input) {\n  let url = base || \"\";\n  for (const index of input.filter((url2) => isNonEmptyURL(url2))) {\n    url = url ? withTrailingSlash(url) + withoutLeadingSlash(index) : index;\n  }\n  return url;\n}\nfunction withHttp(input) {\n  return withProtocol(input, \"http://\");\n}\nfunction withHttps(input) {\n  return withProtocol(input, \"https://\");\n}\nfunction withoutProtocol(input) {\n  return withProtocol(input, \"\");\n}\nfunction withProtocol(input, protocol) {\n  const match = input.match(PROTOCOL_REGEX);\n  if (!match) {\n    return protocol + input;\n  }\n  return protocol + input.slice(match[0].length);\n}\nfunction createURL(input) {\n  return new $URL(input);\n}\nfunction normalizeURL(input) {\n  return createURL(input).toString();\n}\nfunction resolveURL(base, ...input) {\n  const url = createURL(base);\n  for (const index of input.filter((url2) => isNonEmptyURL(url2))) {\n    url.append(createURL(index));\n  }\n  return url.toString();\n}\nfunction isSamePath(p1, p2) {\n  return decode(withoutTrailingSlash(p1)) === decode(withoutTrailingSlash(p2));\n}\nfunction isEqual(a, b, options = {}) {\n  if (!options.trailingSlash) {\n    a = withTrailingSlash(a);\n    b = withTrailingSlash(b);\n  }\n  if (!options.leadingSlash) {\n    a = withLeadingSlash(a);\n    b = withLeadingSlash(b);\n  }\n  if (!options.encoding) {\n    a = decode(a);\n    b = decode(b);\n  }\n  return a === b;\n}\n\nfunction parseURL(input = \"\", defaultProto) {\n  if (!hasProtocol(input, { acceptRelative: true })) {\n    return defaultProto ? parseURL(defaultProto + input) : parsePath(input);\n  }\n  const [protocol = \"\", auth, hostAndPath = \"\"] = (input.replace(/\\\\/g, \"/\").match(/([^/:]+:)?\\/\\/([^/@]+@)?(.*)/) || []).splice(1);\n  const [host = \"\", path = \"\"] = (hostAndPath.match(/([^#/?]*)(.*)?/) || []).splice(1);\n  const { pathname, search, hash } = parsePath(\n    path.replace(/\\/(?=[A-Za-z]:)/, \"\")\n  );\n  return {\n    protocol,\n    auth: auth ? auth.slice(0, Math.max(0, auth.length - 1)) : \"\",\n    host,\n    pathname,\n    search,\n    hash\n  };\n}\nfunction parsePath(input = \"\") {\n  const [pathname = \"\", search = \"\", hash = \"\"] = (input.match(/([^#?]*)(\\?[^#]*)?(#.*)?/) || []).splice(1);\n  return {\n    pathname,\n    search,\n    hash\n  };\n}\nfunction parseAuth(input = \"\") {\n  const [username, password] = input.split(\":\");\n  return {\n    username: decode(username),\n    password: decode(password)\n  };\n}\nfunction parseHost(input = \"\") {\n  const [hostname, port] = (input.match(/([^/:]*):?(\\d+)?/) || []).splice(1);\n  return {\n    hostname: decode(hostname),\n    port\n  };\n}\nfunction stringifyParsedURL(parsed) {\n  const fullpath = parsed.pathname + (parsed.search ? (parsed.search.startsWith(\"?\") ? \"\" : \"?\") + parsed.search : \"\") + parsed.hash;\n  if (!parsed.protocol) {\n    return fullpath;\n  }\n  return parsed.protocol + \"//\" + (parsed.auth ? parsed.auth + \"@\" : \"\") + parsed.host + fullpath;\n}\n\nexports.$URL = $URL;\nexports.cleanDoubleSlashes = cleanDoubleSlashes;\nexports.createURL = createURL;\nexports.decode = decode;\nexports.decodePath = decodePath;\nexports.decodeQueryValue = decodeQueryValue;\nexports.encode = encode;\nexports.encodeHash = encodeHash;\nexports.encodeHost = encodeHost;\nexports.encodeParam = encodeParam;\nexports.encodePath = encodePath;\nexports.encodeQueryItem = encodeQueryItem;\nexports.encodeQueryKey = encodeQueryKey;\nexports.encodeQueryValue = encodeQueryValue;\nexports.getQuery = getQuery;\nexports.hasLeadingSlash = hasLeadingSlash;\nexports.hasProtocol = hasProtocol;\nexports.hasTrailingSlash = hasTrailingSlash;\nexports.isEmptyURL = isEmptyURL;\nexports.isEqual = isEqual;\nexports.isNonEmptyURL = isNonEmptyURL;\nexports.isRelative = isRelative;\nexports.isSamePath = isSamePath;\nexports.joinURL = joinURL;\nexports.normalizeURL = normalizeURL;\nexports.parseAuth = parseAuth;\nexports.parseHost = parseHost;\nexports.parsePath = parsePath;\nexports.parseQuery = parseQuery;\nexports.parseURL = parseURL;\nexports.resolveURL = resolveURL;\nexports.stringifyParsedURL = stringifyParsedURL;\nexports.stringifyQuery = stringifyQuery;\nexports.withBase = withBase;\nexports.withHttp = withHttp;\nexports.withHttps = withHttps;\nexports.withLeadingSlash = withLeadingSlash;\nexports.withProtocol = withProtocol;\nexports.withQuery = withQuery;\nexports.withTrailingSlash = withTrailingSlash;\nexports.withoutBase = withoutBase;\nexports.withoutLeadingSlash = withoutLeadingSlash;\nexports.withoutProtocol = withoutProtocol;\nexports.withoutTrailingSlash = withoutTrailingSlash;\n","'use strict';\n\nconst n = /[^\\0-\\x7E]/;\nconst t = /[\\x2E\\u3002\\uFF0E\\uFF61]/g;\nconst o = { overflow: \"Overflow Error\", \"not-basic\": \"Illegal Input\", \"invalid-input\": \"Invalid Input\" };\nconst e = Math.floor;\nconst r = String.fromCharCode;\nfunction s(n2) {\n  throw new RangeError(o[n2]);\n}\nconst c = function(n2, t2) {\n  return n2 + 22 + 75 * (n2 < 26) - ((t2 != 0) << 5);\n};\nconst u = function(n2, t2, o2) {\n  let r2 = 0;\n  for (n2 = o2 ? e(n2 / 700) : n2 >> 1, n2 += e(n2 / t2); n2 > 455; r2 += 36) {\n    n2 = e(n2 / 35);\n  }\n  return e(r2 + 36 * n2 / (n2 + 38));\n};\nfunction toASCII(o2) {\n  return function(n2, o3) {\n    const e2 = n2.split(\"@\");\n    let r2 = \"\";\n    e2.length > 1 && (r2 = e2[0] + \"@\", n2 = e2[1]);\n    const s2 = function(n3, t2) {\n      const o4 = [];\n      let e3 = n3.length;\n      for (; e3--; ) {\n        o4[e3] = t2(n3[e3]);\n      }\n      return o4;\n    }((n2 = n2.replace(t, \".\")).split(\".\"), o3).join(\".\");\n    return r2 + s2;\n  }(o2, function(t2) {\n    return n.test(t2) ? \"xn--\" + function(n2) {\n      const t3 = [];\n      const o3 = (n2 = function(n3) {\n        const t4 = [];\n        let o4 = 0;\n        const e2 = n3.length;\n        for (; o4 < e2; ) {\n          const r2 = n3.charCodeAt(o4++);\n          if (r2 >= 55296 && r2 <= 56319 && o4 < e2) {\n            const e3 = n3.charCodeAt(o4++);\n            (64512 & e3) == 56320 ? t4.push(((1023 & r2) << 10) + (1023 & e3) + 65536) : (t4.push(r2), o4--);\n          } else {\n            t4.push(r2);\n          }\n        }\n        return t4;\n      }(n2)).length;\n      let f = 128;\n      let i = 0;\n      let l = 72;\n      for (const o4 of n2) {\n        o4 < 128 && t3.push(r(o4));\n      }\n      const h = t3.length;\n      let p = h;\n      for (h && t3.push(\"-\"); p < o3; ) {\n        let o4 = 2147483647;\n        for (const t4 of n2) {\n          t4 >= f && t4 < o4 && (o4 = t4);\n        }\n        const a = p + 1;\n        o4 - f > e((2147483647 - i) / a) && s(\"overflow\"), i += (o4 - f) * a, f = o4;\n        for (const o5 of n2) {\n          if (o5 < f && ++i > 2147483647 && s(\"overflow\"), o5 == f) {\n            let n3 = i;\n            for (let o6 = 36; ; o6 += 36) {\n              const s2 = o6 <= l ? 1 : o6 >= l + 26 ? 26 : o6 - l;\n              if (n3 < s2) {\n                break;\n              }\n              const u2 = n3 - s2;\n              const f2 = 36 - s2;\n              t3.push(r(c(s2 + u2 % f2, 0))), n3 = e(u2 / f2);\n            }\n            t3.push(r(c(n3, 0))), l = u(i, a, p == h), i = 0, ++p;\n          }\n        }\n        ++i, ++f;\n      }\n      return t3.join(\"\");\n    }(t2) : t2;\n  });\n}\n\nconst HASH_RE = /#/g;\nconst AMPERSAND_RE = /&/g;\nconst SLASH_RE = /\\//g;\nconst EQUAL_RE = /=/g;\nconst IM_RE = /\\?/g;\nconst PLUS_RE = /\\+/g;\nconst ENC_BRACKET_OPEN_RE = /%5B/gi;\nconst ENC_BRACKET_CLOSE_RE = /%5D/gi;\nconst ENC_CARET_RE = /%5E/gi;\nconst ENC_BACKTICK_RE = /%60/gi;\nconst ENC_CURLY_OPEN_RE = /%7B/gi;\nconst ENC_PIPE_RE = /%7C/gi;\nconst ENC_CURLY_CLOSE_RE = /%7D/gi;\nconst ENC_SPACE_RE = /%20/gi;\nconst ENC_SLASH_RE = /%2F/gi;\nconst ENC_ENC_SLASH_RE = /%252F/gi;\nfunction encode(text) {\n  return encodeURI(\"\" + text).replace(ENC_PIPE_RE, \"|\").replace(ENC_BRACKET_OPEN_RE, \"[\").replace(ENC_BRACKET_CLOSE_RE, \"]\");\n}\nfunction encodeHash(text) {\n  return encode(text).replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryValue(text) {\n  return encode(text).replace(PLUS_RE, \"%2B\").replace(ENC_SPACE_RE, \"+\").replace(HASH_RE, \"%23\").replace(AMPERSAND_RE, \"%26\").replace(ENC_BACKTICK_RE, \"`\").replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryKey(text) {\n  return encodeQueryValue(text).replace(EQUAL_RE, \"%3D\");\n}\nfunction encodePath(text) {\n  return encode(text).replace(HASH_RE, \"%23\").replace(IM_RE, \"%3F\").replace(ENC_ENC_SLASH_RE, \"%2F\").replace(AMPERSAND_RE, \"%26\").replace(PLUS_RE, \"%2B\");\n}\nfunction encodeParam(text) {\n  return encodePath(text).replace(SLASH_RE, \"%2F\");\n}\nfunction decode(text = \"\") {\n  try {\n    return decodeURIComponent(\"\" + text);\n  } catch (_err) {\n    return \"\" + text;\n  }\n}\nfunction decodePath(text) {\n  return decode(text.replace(ENC_SLASH_RE, \"%252F\"));\n}\nfunction decodeQueryValue(text) {\n  return decode(text.replace(PLUS_RE, \" \"));\n}\nfunction encodeHost(name = \"\") {\n  return toASCII(name);\n}\n\nfunction parseQuery(paramsStr = \"\") {\n  const obj = {};\n  if (paramsStr[0] === \"?\") {\n    paramsStr = paramsStr.substr(1);\n  }\n  for (const param of paramsStr.split(\"&\")) {\n    const s = param.match(/([^=]+)=?(.*)/) || [];\n    if (s.length < 2) {\n      continue;\n    }\n    const key = decode(s[1]);\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = decodeQueryValue(s[2] || \"\");\n    if (obj[key]) {\n      if (Array.isArray(obj[key])) {\n        obj[key].push(value);\n      } else {\n        obj[key] = [obj[key], value];\n      }\n    } else {\n      obj[key] = value;\n    }\n  }\n  return obj;\n}\nfunction encodeQueryItem(key, val) {\n  if (typeof val === \"number\" || typeof val === \"boolean\") {\n    val = String(val);\n  }\n  if (!val) {\n    return encodeQueryKey(key);\n  }\n  if (Array.isArray(val)) {\n    return val.map((_val) => `${encodeQueryKey(key)}=${encodeQueryValue(_val)}`).join(\"&\");\n  }\n  return `${encodeQueryKey(key)}=${encodeQueryValue(val)}`;\n}\nfunction stringifyQuery(query) {\n  return Object.keys(query).map((k) => encodeQueryItem(k, query[k])).join(\"&\");\n}\n\nclass $URL {\n  constructor(input = \"\") {\n    this.query = {};\n    if (typeof input !== \"string\") {\n      throw new TypeError(`URL input should be string received ${typeof input} (${input})`);\n    }\n    const parsed = parseURL(input);\n    this.protocol = decode(parsed.protocol);\n    this.host = decode(parsed.host);\n    this.auth = decode(parsed.auth);\n    this.pathname = decodePath(parsed.pathname);\n    this.query = parseQuery(parsed.search);\n    this.hash = decode(parsed.hash);\n  }\n  get hostname() {\n    return parseHost(this.host).hostname;\n  }\n  get port() {\n    return parseHost(this.host).port || \"\";\n  }\n  get username() {\n    return parseAuth(this.auth).username;\n  }\n  get password() {\n    return parseAuth(this.auth).password || \"\";\n  }\n  get hasProtocol() {\n    return this.protocol.length;\n  }\n  get isAbsolute() {\n    return this.hasProtocol || this.pathname[0] === \"/\";\n  }\n  get search() {\n    const q = stringifyQuery(this.query);\n    return q.length ? \"?\" + q : \"\";\n  }\n  get searchParams() {\n    const p = new URLSearchParams();\n    for (const name in this.query) {\n      const value = this.query[name];\n      if (Array.isArray(value)) {\n        value.forEach((v) => p.append(name, v));\n      } else {\n        p.append(name, value || \"\");\n      }\n    }\n    return p;\n  }\n  get origin() {\n    return (this.protocol ? this.protocol + \"//\" : \"\") + encodeHost(this.host);\n  }\n  get fullpath() {\n    return encodePath(this.pathname) + this.search + encodeHash(this.hash);\n  }\n  get encodedAuth() {\n    if (!this.auth) {\n      return \"\";\n    }\n    const { username, password } = parseAuth(this.auth);\n    return encodeURIComponent(username) + (password ? \":\" + encodeURIComponent(password) : \"\");\n  }\n  get href() {\n    const auth = this.encodedAuth;\n    const originWithAuth = (this.protocol ? this.protocol + \"//\" : \"\") + (auth ? auth + \"@\" : \"\") + encodeHost(this.host);\n    return this.hasProtocol && this.isAbsolute ? originWithAuth + this.fullpath : this.fullpath;\n  }\n  append(url) {\n    if (url.hasProtocol) {\n      throw new Error(\"Cannot append a URL with protocol\");\n    }\n    Object.assign(this.query, url.query);\n    if (url.pathname) {\n      this.pathname = withTrailingSlash(this.pathname) + withoutLeadingSlash(url.pathname);\n    }\n    if (url.hash) {\n      this.hash = url.hash;\n    }\n  }\n  toJSON() {\n    return this.href;\n  }\n  toString() {\n    return this.href;\n  }\n}\n\nfunction isRelative(inputStr) {\n  return [\"./\", \"../\"].some((str) => inputStr.startsWith(str));\n}\nconst PROTOCOL_REGEX = /^\\w+:(\\/\\/)?/;\nconst PROTOCOL_RELATIVE_REGEX = /^\\/\\/[^/]+/;\nfunction hasProtocol(inputStr, acceptProtocolRelative = false) {\n  return PROTOCOL_REGEX.test(inputStr) || acceptProtocolRelative && PROTOCOL_RELATIVE_REGEX.test(inputStr);\n}\nconst TRAILING_SLASH_RE = /\\/$|\\/\\?/;\nfunction hasTrailingSlash(input = \"\", queryParams = false) {\n  if (!queryParams) {\n    return input.endsWith(\"/\");\n  }\n  return TRAILING_SLASH_RE.test(input);\n}\nfunction withoutTrailingSlash(input = \"\", queryParams = false) {\n  if (!queryParams) {\n    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || \"/\";\n  }\n  if (!hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  const [s0, ...s] = input.split(\"?\");\n  return (s0.slice(0, -1) || \"/\") + (s.length ? `?${s.join(\"?\")}` : \"\");\n}\nfunction withTrailingSlash(input = \"\", queryParams = false) {\n  if (!queryParams) {\n    return input.endsWith(\"/\") ? input : input + \"/\";\n  }\n  if (hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  const [s0, ...s] = input.split(\"?\");\n  return s0 + \"/\" + (s.length ? `?${s.join(\"?\")}` : \"\");\n}\nfunction hasLeadingSlash(input = \"\") {\n  return input.startsWith(\"/\");\n}\nfunction withoutLeadingSlash(input = \"\") {\n  return (hasLeadingSlash(input) ? input.substr(1) : input) || \"/\";\n}\nfunction withLeadingSlash(input = \"\") {\n  return hasLeadingSlash(input) ? input : \"/\" + input;\n}\nfunction cleanDoubleSlashes(input = \"\") {\n  return input.split(\"://\").map((str) => str.replace(/\\/{2,}/g, \"/\")).join(\"://\");\n}\nfunction withBase(input, base) {\n  if (isEmptyURL(base) || hasProtocol(input)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (input.startsWith(_base)) {\n    return input;\n  }\n  return joinURL(_base, input);\n}\nfunction withoutBase(input, base) {\n  if (isEmptyURL(base)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (!input.startsWith(_base)) {\n    return input;\n  }\n  const trimmed = input.substring(_base.length);\n  return trimmed[0] === \"/\" ? trimmed : \"/\" + trimmed;\n}\nfunction withQuery(input, query) {\n  const parsed = parseURL(input);\n  const mergedQuery = { ...parseQuery(parsed.search), ...query };\n  parsed.search = stringifyQuery(mergedQuery);\n  return stringifyParsedURL(parsed);\n}\nfunction getQuery(input) {\n  return parseQuery(parseURL(input).search);\n}\nfunction isEmptyURL(url) {\n  return !url || url === \"/\";\n}\nfunction isNonEmptyURL(url) {\n  return url && url !== \"/\";\n}\nfunction joinURL(base, ...input) {\n  let url = base || \"\";\n  for (const i of input.filter(isNonEmptyURL)) {\n    url = url ? withTrailingSlash(url) + withoutLeadingSlash(i) : i;\n  }\n  return url;\n}\nfunction withHttp(input) {\n  return withProtocol(input, \"http://\");\n}\nfunction withHttps(input) {\n  return withProtocol(input, \"https://\");\n}\nfunction withoutProtocol(input) {\n  return withProtocol(input, \"\");\n}\nfunction withProtocol(input, protocol) {\n  const match = input.match(PROTOCOL_REGEX);\n  if (!match) {\n    return protocol + input;\n  }\n  return protocol + input.substring(match[0].length);\n}\nfunction createURL(input) {\n  return new $URL(input);\n}\nfunction normalizeURL(input) {\n  return createURL(input).toString();\n}\nfunction resolveURL(base, ...input) {\n  const url = createURL(base);\n  for (const i of input.filter(isNonEmptyURL)) {\n    url.append(createURL(i));\n  }\n  return url.toString();\n}\nfunction isSamePath(p1, p2) {\n  return decode(withoutTrailingSlash(p1)) === decode(withoutTrailingSlash(p2));\n}\nfunction isEqual(a, b, opts = {}) {\n  if (!opts.trailingSlash) {\n    a = withTrailingSlash(a);\n    b = withTrailingSlash(b);\n  }\n  if (!opts.leadingSlash) {\n    a = withLeadingSlash(a);\n    b = withLeadingSlash(b);\n  }\n  if (!opts.encoding) {\n    a = decode(a);\n    b = decode(b);\n  }\n  return a === b;\n}\n\nfunction parseURL(input = \"\", defaultProto) {\n  if (!hasProtocol(input, true)) {\n    return defaultProto ? parseURL(defaultProto + input) : parsePath(input);\n  }\n  const [protocol = \"\", auth, hostAndPath = \"\"] = (input.replace(/\\\\/g, \"/\").match(/([^:/]+:)?\\/\\/([^/@]+@)?(.*)/) || []).splice(1);\n  const [host = \"\", path = \"\"] = (hostAndPath.match(/([^/?#]*)(.*)?/) || []).splice(1);\n  const { pathname, search, hash } = parsePath(path);\n  return {\n    protocol,\n    auth: auth ? auth.substr(0, auth.length - 1) : \"\",\n    host,\n    pathname,\n    search,\n    hash\n  };\n}\nfunction parsePath(input = \"\") {\n  const [pathname = \"\", search = \"\", hash = \"\"] = (input.match(/([^#?]*)(\\?[^#]*)?(#.*)?/) || []).splice(1);\n  return {\n    pathname,\n    search,\n    hash\n  };\n}\nfunction parseAuth(input = \"\") {\n  const [username, password] = input.split(\":\");\n  return {\n    username: decode(username),\n    password: decode(password)\n  };\n}\nfunction parseHost(input = \"\") {\n  const [hostname, port] = (input.match(/([^/]*)(:0-9+)?/) || []).splice(1);\n  return {\n    hostname: decode(hostname),\n    port\n  };\n}\nfunction stringifyParsedURL(parsed) {\n  const fullpath = parsed.pathname + (parsed.search ? (parsed.search.startsWith(\"?\") ? \"\" : \"?\") + parsed.search : \"\") + parsed.hash;\n  if (!parsed.protocol) {\n    return fullpath;\n  }\n  return parsed.protocol + \"//\" + (parsed.auth ? parsed.auth + \"@\" : \"\") + parsed.host + fullpath;\n}\n\nexports.$URL = $URL;\nexports.cleanDoubleSlashes = cleanDoubleSlashes;\nexports.createURL = createURL;\nexports.decode = decode;\nexports.decodePath = decodePath;\nexports.decodeQueryValue = decodeQueryValue;\nexports.encode = encode;\nexports.encodeHash = encodeHash;\nexports.encodeHost = encodeHost;\nexports.encodeParam = encodeParam;\nexports.encodePath = encodePath;\nexports.encodeQueryItem = encodeQueryItem;\nexports.encodeQueryKey = encodeQueryKey;\nexports.encodeQueryValue = encodeQueryValue;\nexports.getQuery = getQuery;\nexports.hasLeadingSlash = hasLeadingSlash;\nexports.hasProtocol = hasProtocol;\nexports.hasTrailingSlash = hasTrailingSlash;\nexports.isEmptyURL = isEmptyURL;\nexports.isEqual = isEqual;\nexports.isNonEmptyURL = isNonEmptyURL;\nexports.isRelative = isRelative;\nexports.isSamePath = isSamePath;\nexports.joinURL = joinURL;\nexports.normalizeURL = normalizeURL;\nexports.parseAuth = parseAuth;\nexports.parseHost = parseHost;\nexports.parsePath = parsePath;\nexports.parseQuery = parseQuery;\nexports.parseURL = parseURL;\nexports.resolveURL = resolveURL;\nexports.stringifyParsedURL = stringifyParsedURL;\nexports.stringifyQuery = stringifyQuery;\nexports.withBase = withBase;\nexports.withHttp = withHttp;\nexports.withHttps = withHttps;\nexports.withLeadingSlash = withLeadingSlash;\nexports.withProtocol = withProtocol;\nexports.withQuery = withQuery;\nexports.withTrailingSlash = withTrailingSlash;\nexports.withoutBase = withoutBase;\nexports.withoutLeadingSlash = withoutLeadingSlash;\nexports.withoutProtocol = withoutProtocol;\nexports.withoutTrailingSlash = withoutTrailingSlash;\n","/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nexport default function normalizeComponent(\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier /* server only */,\n  shadowMode /* vue-cli only */\n) {\n  // Vue.extend constructor export interop\n  var options =\n    typeof scriptExports === 'function' ? scriptExports.options : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = 'data-v-' + scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) {\n    // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () {\n          injectStyles.call(\n            this,\n            (options.functional ? this.parent : this).$root.$options.shadowRoot\n          )\n        }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functional component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection(h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing ? [].concat(existing, hook) : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n","'use strict';\n\nconst n = /[^\\0-\\x7E]/;\nconst t = /[\\x2E\\u3002\\uFF0E\\uFF61]/g;\nconst o = { overflow: \"Overflow Error\", \"not-basic\": \"Illegal Input\", \"invalid-input\": \"Invalid Input\" };\nconst e = Math.floor;\nconst r = String.fromCharCode;\nfunction s(n2) {\n  throw new RangeError(o[n2]);\n}\nconst c = function(n2, t2) {\n  return n2 + 22 + 75 * (n2 < 26) - ((t2 != 0) << 5);\n};\nconst u = function(n2, t2, o2) {\n  let r2 = 0;\n  for (n2 = o2 ? e(n2 / 700) : n2 >> 1, n2 += e(n2 / t2); n2 > 455; r2 += 36) {\n    n2 = e(n2 / 35);\n  }\n  return e(r2 + 36 * n2 / (n2 + 38));\n};\nfunction toASCII(o2) {\n  return function(n2, o3) {\n    const e2 = n2.split(\"@\");\n    let r2 = \"\";\n    e2.length > 1 && (r2 = e2[0] + \"@\", n2 = e2[1]);\n    const s2 = function(n3, t2) {\n      const o4 = [];\n      let e3 = n3.length;\n      for (; e3--; ) {\n        o4[e3] = t2(n3[e3]);\n      }\n      return o4;\n    }((n2 = n2.replace(t, \".\")).split(\".\"), o3).join(\".\");\n    return r2 + s2;\n  }(o2, function(t2) {\n    return n.test(t2) ? \"xn--\" + function(n2) {\n      const t3 = [];\n      const o3 = (n2 = function(n3) {\n        const t4 = [];\n        let o4 = 0;\n        const e2 = n3.length;\n        for (; o4 < e2; ) {\n          const r2 = n3.charCodeAt(o4++);\n          if (r2 >= 55296 && r2 <= 56319 && o4 < e2) {\n            const e3 = n3.charCodeAt(o4++);\n            (64512 & e3) == 56320 ? t4.push(((1023 & r2) << 10) + (1023 & e3) + 65536) : (t4.push(r2), o4--);\n          } else {\n            t4.push(r2);\n          }\n        }\n        return t4;\n      }(n2)).length;\n      let f = 128;\n      let i = 0;\n      let l = 72;\n      for (const o4 of n2) {\n        o4 < 128 && t3.push(r(o4));\n      }\n      const h = t3.length;\n      let p = h;\n      for (h && t3.push(\"-\"); p < o3; ) {\n        let o4 = 2147483647;\n        for (const t4 of n2) {\n          t4 >= f && t4 < o4 && (o4 = t4);\n        }\n        const a = p + 1;\n        o4 - f > e((2147483647 - i) / a) && s(\"overflow\"), i += (o4 - f) * a, f = o4;\n        for (const o5 of n2) {\n          if (o5 < f && ++i > 2147483647 && s(\"overflow\"), o5 == f) {\n            let n3 = i;\n            for (let o6 = 36; ; o6 += 36) {\n              const s2 = o6 <= l ? 1 : o6 >= l + 26 ? 26 : o6 - l;\n              if (n3 < s2) {\n                break;\n              }\n              const u2 = n3 - s2;\n              const f2 = 36 - s2;\n              t3.push(r(c(s2 + u2 % f2, 0))), n3 = e(u2 / f2);\n            }\n            t3.push(r(c(n3, 0))), l = u(i, a, p == h), i = 0, ++p;\n          }\n        }\n        ++i, ++f;\n      }\n      return t3.join(\"\");\n    }(t2) : t2;\n  });\n}\n\nconst HASH_RE = /#/g;\nconst AMPERSAND_RE = /&/g;\nconst SLASH_RE = /\\//g;\nconst EQUAL_RE = /=/g;\nconst IM_RE = /\\?/g;\nconst PLUS_RE = /\\+/g;\nconst ENC_BRACKET_OPEN_RE = /%5B/gi;\nconst ENC_BRACKET_CLOSE_RE = /%5D/gi;\nconst ENC_CARET_RE = /%5E/gi;\nconst ENC_BACKTICK_RE = /%60/gi;\nconst ENC_CURLY_OPEN_RE = /%7B/gi;\nconst ENC_PIPE_RE = /%7C/gi;\nconst ENC_CURLY_CLOSE_RE = /%7D/gi;\nconst ENC_SPACE_RE = /%20/gi;\nconst ENC_SLASH_RE = /%2F/gi;\nconst ENC_ENC_SLASH_RE = /%252F/gi;\nfunction encode(text) {\n  return encodeURI(\"\" + text).replace(ENC_PIPE_RE, \"|\").replace(ENC_BRACKET_OPEN_RE, \"[\").replace(ENC_BRACKET_CLOSE_RE, \"]\");\n}\nfunction encodeHash(text) {\n  return encode(text).replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryValue(text) {\n  return encode(text).replace(PLUS_RE, \"%2B\").replace(ENC_SPACE_RE, \"+\").replace(HASH_RE, \"%23\").replace(AMPERSAND_RE, \"%26\").replace(ENC_BACKTICK_RE, \"`\").replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryKey(text) {\n  return encodeQueryValue(text).replace(EQUAL_RE, \"%3D\");\n}\nfunction encodePath(text) {\n  return encode(text).replace(HASH_RE, \"%23\").replace(IM_RE, \"%3F\").replace(ENC_ENC_SLASH_RE, \"%2F\").replace(AMPERSAND_RE, \"%26\").replace(PLUS_RE, \"%2B\");\n}\nfunction encodeParam(text) {\n  return encodePath(text).replace(SLASH_RE, \"%2F\");\n}\nfunction decode(text = \"\") {\n  try {\n    return decodeURIComponent(\"\" + text);\n  } catch (_err) {\n    return \"\" + text;\n  }\n}\nfunction decodePath(text) {\n  return decode(text.replace(ENC_SLASH_RE, \"%252F\"));\n}\nfunction decodeQueryValue(text) {\n  return decode(text.replace(PLUS_RE, \" \"));\n}\nfunction encodeHost(name = \"\") {\n  return toASCII(name);\n}\n\nfunction parseQuery(paramsStr = \"\") {\n  const obj = {};\n  if (paramsStr[0] === \"?\") {\n    paramsStr = paramsStr.substr(1);\n  }\n  for (const param of paramsStr.split(\"&\")) {\n    const s = param.match(/([^=]+)=?(.*)/) || [];\n    if (s.length < 2) {\n      continue;\n    }\n    const key = decode(s[1]);\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = decodeQueryValue(s[2] || \"\");\n    if (obj[key]) {\n      if (Array.isArray(obj[key])) {\n        obj[key].push(value);\n      } else {\n        obj[key] = [obj[key], value];\n      }\n    } else {\n      obj[key] = value;\n    }\n  }\n  return obj;\n}\nfunction encodeQueryItem(key, val) {\n  if (typeof val === \"number\" || typeof val === \"boolean\") {\n    val = String(val);\n  }\n  if (!val) {\n    return encodeQueryKey(key);\n  }\n  if (Array.isArray(val)) {\n    return val.map((_val) => `${encodeQueryKey(key)}=${encodeQueryValue(_val)}`).join(\"&\");\n  }\n  return `${encodeQueryKey(key)}=${encodeQueryValue(val)}`;\n}\nfunction stringifyQuery(query) {\n  return Object.keys(query).map((k) => encodeQueryItem(k, query[k])).join(\"&\");\n}\n\nclass $URL {\n  constructor(input = \"\") {\n    this.query = {};\n    if (typeof input !== \"string\") {\n      throw new TypeError(`URL input should be string received ${typeof input} (${input})`);\n    }\n    const parsed = parseURL(input);\n    this.protocol = decode(parsed.protocol);\n    this.host = decode(parsed.host);\n    this.auth = decode(parsed.auth);\n    this.pathname = decodePath(parsed.pathname);\n    this.query = parseQuery(parsed.search);\n    this.hash = decode(parsed.hash);\n  }\n  get hostname() {\n    return parseHost(this.host).hostname;\n  }\n  get port() {\n    return parseHost(this.host).port || \"\";\n  }\n  get username() {\n    return parseAuth(this.auth).username;\n  }\n  get password() {\n    return parseAuth(this.auth).password || \"\";\n  }\n  get hasProtocol() {\n    return this.protocol.length;\n  }\n  get isAbsolute() {\n    return this.hasProtocol || this.pathname[0] === \"/\";\n  }\n  get search() {\n    const q = stringifyQuery(this.query);\n    return q.length ? \"?\" + q : \"\";\n  }\n  get searchParams() {\n    const p = new URLSearchParams();\n    for (const name in this.query) {\n      const value = this.query[name];\n      if (Array.isArray(value)) {\n        value.forEach((v) => p.append(name, v));\n      } else {\n        p.append(name, value || \"\");\n      }\n    }\n    return p;\n  }\n  get origin() {\n    return (this.protocol ? this.protocol + \"//\" : \"\") + encodeHost(this.host);\n  }\n  get fullpath() {\n    return encodePath(this.pathname) + this.search + encodeHash(this.hash);\n  }\n  get encodedAuth() {\n    if (!this.auth) {\n      return \"\";\n    }\n    const { username, password } = parseAuth(this.auth);\n    return encodeURIComponent(username) + (password ? \":\" + encodeURIComponent(password) : \"\");\n  }\n  get href() {\n    const auth = this.encodedAuth;\n    const originWithAuth = (this.protocol ? this.protocol + \"//\" : \"\") + (auth ? auth + \"@\" : \"\") + encodeHost(this.host);\n    return this.hasProtocol && this.isAbsolute ? originWithAuth + this.fullpath : this.fullpath;\n  }\n  append(url) {\n    if (url.hasProtocol) {\n      throw new Error(\"Cannot append a URL with protocol\");\n    }\n    Object.assign(this.query, url.query);\n    if (url.pathname) {\n      this.pathname = withTrailingSlash(this.pathname) + withoutLeadingSlash(url.pathname);\n    }\n    if (url.hash) {\n      this.hash = url.hash;\n    }\n  }\n  toJSON() {\n    return this.href;\n  }\n  toString() {\n    return this.href;\n  }\n}\n\nfunction isRelative(inputStr) {\n  return [\"./\", \"../\"].some((str) => inputStr.startsWith(str));\n}\nconst PROTOCOL_REGEX = /^\\w+:(\\/\\/)?/;\nconst PROTOCOL_RELATIVE_REGEX = /^\\/\\/[^/]+/;\nfunction hasProtocol(inputStr, acceptProtocolRelative = false) {\n  return PROTOCOL_REGEX.test(inputStr) || acceptProtocolRelative && PROTOCOL_RELATIVE_REGEX.test(inputStr);\n}\nconst TRAILING_SLASH_RE = /\\/$|\\/\\?/;\nfunction hasTrailingSlash(input = \"\", queryParams = false) {\n  if (!queryParams) {\n    return input.endsWith(\"/\");\n  }\n  return TRAILING_SLASH_RE.test(input);\n}\nfunction withoutTrailingSlash(input = \"\", queryParams = false) {\n  if (!queryParams) {\n    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || \"/\";\n  }\n  if (!hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  const [s0, ...s] = input.split(\"?\");\n  return (s0.slice(0, -1) || \"/\") + (s.length ? `?${s.join(\"?\")}` : \"\");\n}\nfunction withTrailingSlash(input = \"\", queryParams = false) {\n  if (!queryParams) {\n    return input.endsWith(\"/\") ? input : input + \"/\";\n  }\n  if (hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  const [s0, ...s] = input.split(\"?\");\n  return s0 + \"/\" + (s.length ? `?${s.join(\"?\")}` : \"\");\n}\nfunction hasLeadingSlash(input = \"\") {\n  return input.startsWith(\"/\");\n}\nfunction withoutLeadingSlash(input = \"\") {\n  return (hasLeadingSlash(input) ? input.substr(1) : input) || \"/\";\n}\nfunction withLeadingSlash(input = \"\") {\n  return hasLeadingSlash(input) ? input : \"/\" + input;\n}\nfunction cleanDoubleSlashes(input = \"\") {\n  return input.split(\"://\").map((str) => str.replace(/\\/{2,}/g, \"/\")).join(\"://\");\n}\nfunction withBase(input, base) {\n  if (isEmptyURL(base) || hasProtocol(input)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (input.startsWith(_base)) {\n    return input;\n  }\n  return joinURL(_base, input);\n}\nfunction withoutBase(input, base) {\n  if (isEmptyURL(base)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (!input.startsWith(_base)) {\n    return input;\n  }\n  const trimmed = input.substring(_base.length);\n  return trimmed[0] === \"/\" ? trimmed : \"/\" + trimmed;\n}\nfunction withQuery(input, query) {\n  const parsed = parseURL(input);\n  const mergedQuery = { ...parseQuery(parsed.search), ...query };\n  parsed.search = stringifyQuery(mergedQuery);\n  return stringifyParsedURL(parsed);\n}\nfunction getQuery(input) {\n  return parseQuery(parseURL(input).search);\n}\nfunction isEmptyURL(url) {\n  return !url || url === \"/\";\n}\nfunction isNonEmptyURL(url) {\n  return url && url !== \"/\";\n}\nfunction joinURL(base, ...input) {\n  let url = base || \"\";\n  for (const i of input.filter(isNonEmptyURL)) {\n    url = url ? withTrailingSlash(url) + withoutLeadingSlash(i) : i;\n  }\n  return url;\n}\nfunction withHttp(input) {\n  return withProtocol(input, \"http://\");\n}\nfunction withHttps(input) {\n  return withProtocol(input, \"https://\");\n}\nfunction withoutProtocol(input) {\n  return withProtocol(input, \"\");\n}\nfunction withProtocol(input, protocol) {\n  const match = input.match(PROTOCOL_REGEX);\n  if (!match) {\n    return protocol + input;\n  }\n  return protocol + input.substring(match[0].length);\n}\nfunction createURL(input) {\n  return new $URL(input);\n}\nfunction normalizeURL(input) {\n  return createURL(input).toString();\n}\nfunction resolveURL(base, ...input) {\n  const url = createURL(base);\n  for (const i of input.filter(isNonEmptyURL)) {\n    url.append(createURL(i));\n  }\n  return url.toString();\n}\nfunction isSamePath(p1, p2) {\n  return decode(withoutTrailingSlash(p1)) === decode(withoutTrailingSlash(p2));\n}\nfunction isEqual(a, b, opts = {}) {\n  if (!opts.trailingSlash) {\n    a = withTrailingSlash(a);\n    b = withTrailingSlash(b);\n  }\n  if (!opts.leadingSlash) {\n    a = withLeadingSlash(a);\n    b = withLeadingSlash(b);\n  }\n  if (!opts.encoding) {\n    a = decode(a);\n    b = decode(b);\n  }\n  return a === b;\n}\n\nfunction parseURL(input = \"\", defaultProto) {\n  if (!hasProtocol(input, true)) {\n    return defaultProto ? parseURL(defaultProto + input) : parsePath(input);\n  }\n  const [protocol = \"\", auth, hostAndPath = \"\"] = (input.replace(/\\\\/g, \"/\").match(/([^:/]+:)?\\/\\/([^/@]+@)?(.*)/) || []).splice(1);\n  const [host = \"\", path = \"\"] = (hostAndPath.match(/([^/?#]*)(.*)?/) || []).splice(1);\n  const { pathname, search, hash } = parsePath(path);\n  return {\n    protocol,\n    auth: auth ? auth.substr(0, auth.length - 1) : \"\",\n    host,\n    pathname,\n    search,\n    hash\n  };\n}\nfunction parsePath(input = \"\") {\n  const [pathname = \"\", search = \"\", hash = \"\"] = (input.match(/([^#?]*)(\\?[^#]*)?(#.*)?/) || []).splice(1);\n  return {\n    pathname,\n    search,\n    hash\n  };\n}\nfunction parseAuth(input = \"\") {\n  const [username, password] = input.split(\":\");\n  return {\n    username: decode(username),\n    password: decode(password)\n  };\n}\nfunction parseHost(input = \"\") {\n  const [hostname, port] = (input.match(/([^/]*)(:0-9+)?/) || []).splice(1);\n  return {\n    hostname: decode(hostname),\n    port\n  };\n}\nfunction stringifyParsedURL(parsed) {\n  const fullpath = parsed.pathname + (parsed.search ? (parsed.search.startsWith(\"?\") ? \"\" : \"?\") + parsed.search : \"\") + parsed.hash;\n  if (!parsed.protocol) {\n    return fullpath;\n  }\n  return parsed.protocol + \"//\" + (parsed.auth ? parsed.auth + \"@\" : \"\") + parsed.host + fullpath;\n}\n\nexports.$URL = $URL;\nexports.cleanDoubleSlashes = cleanDoubleSlashes;\nexports.createURL = createURL;\nexports.decode = decode;\nexports.decodePath = decodePath;\nexports.decodeQueryValue = decodeQueryValue;\nexports.encode = encode;\nexports.encodeHash = encodeHash;\nexports.encodeHost = encodeHost;\nexports.encodeParam = encodeParam;\nexports.encodePath = encodePath;\nexports.encodeQueryItem = encodeQueryItem;\nexports.encodeQueryKey = encodeQueryKey;\nexports.encodeQueryValue = encodeQueryValue;\nexports.getQuery = getQuery;\nexports.hasLeadingSlash = hasLeadingSlash;\nexports.hasProtocol = hasProtocol;\nexports.hasTrailingSlash = hasTrailingSlash;\nexports.isEmptyURL = isEmptyURL;\nexports.isEqual = isEqual;\nexports.isNonEmptyURL = isNonEmptyURL;\nexports.isRelative = isRelative;\nexports.isSamePath = isSamePath;\nexports.joinURL = joinURL;\nexports.normalizeURL = normalizeURL;\nexports.parseAuth = parseAuth;\nexports.parseHost = parseHost;\nexports.parsePath = parsePath;\nexports.parseQuery = parseQuery;\nexports.parseURL = parseURL;\nexports.resolveURL = resolveURL;\nexports.stringifyParsedURL = stringifyParsedURL;\nexports.stringifyQuery = stringifyQuery;\nexports.withBase = withBase;\nexports.withHttp = withHttp;\nexports.withHttps = withHttps;\nexports.withLeadingSlash = withLeadingSlash;\nexports.withProtocol = withProtocol;\nexports.withQuery = withQuery;\nexports.withTrailingSlash = withTrailingSlash;\nexports.withoutBase = withoutBase;\nexports.withoutLeadingSlash = withoutLeadingSlash;\nexports.withoutProtocol = withoutProtocol;\nexports.withoutTrailingSlash = withoutTrailingSlash;\n","module.exports = require(\"vue-meta\");","module.exports = require(\"axios\");","module.exports = require(\"url\");","module.exports = require(\"vue-no-ssr\");","module.exports = require(\"cookie\");","module.exports = require(\"vue-client-only\");","module.exports = require(\"vue-router\");","module.exports = require(\"vue-i18n\");","'use strict';\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\nfunction isObject(value) {\n  return value !== null && typeof value === \"object\";\n}\nfunction _defu(baseObject, defaults, namespace = \".\", merger) {\n  if (!isObject(defaults)) {\n    return _defu(baseObject, {}, namespace, merger);\n  }\n  const object = Object.assign({}, defaults);\n  for (const key in baseObject) {\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = baseObject[key];\n    if (value === null || value === void 0) {\n      continue;\n    }\n    if (merger && merger(object, key, value, namespace)) {\n      continue;\n    }\n    if (Array.isArray(value) && Array.isArray(object[key])) {\n      object[key] = [...value, ...object[key]];\n    } else if (isObject(value) && isObject(object[key])) {\n      object[key] = _defu(\n        value,\n        object[key],\n        (namespace ? `${namespace}.` : \"\") + key.toString(),\n        merger\n      );\n    } else {\n      object[key] = value;\n    }\n  }\n  return object;\n}\nfunction createDefu(merger) {\n  return (...arguments_) => (\n    // eslint-disable-next-line unicorn/no-array-reduce\n    arguments_.reduce((p, c) => _defu(p, c, \"\", merger), {})\n  );\n}\nconst defu = createDefu();\nconst defuFn = createDefu((object, key, currentValue) => {\n  if (typeof object[key] !== \"undefined\" && typeof currentValue === \"function\") {\n    object[key] = currentValue(object[key]);\n    return true;\n  }\n});\nconst defuArrayFn = createDefu((object, key, currentValue) => {\n  if (Array.isArray(object[key]) && typeof currentValue === \"function\") {\n    object[key] = currentValue(object[key]);\n    return true;\n  }\n});\n\nexports.createDefu = createDefu;\nexports.default = defu;\nexports.defu = defu;\nexports.defuArrayFn = defuArrayFn;\nexports.defuFn = defuFn;\n","// Exports\nmodule.exports = {\n\n};\n","module.exports = require(\"node-fetch-native\");","'use strict';\n\nfunction isHTTPS(req, trustProxy = true) {\n  const _xForwardedProto = trustProxy && req.headers ? req.headers[\"x-forwarded-proto\"] : void 0;\n  const protoCheck = typeof _xForwardedProto === \"string\" ? _xForwardedProto.includes(\"https\") : void 0;\n  if (protoCheck) {\n    return true;\n  }\n  const _encrypted = req.connection ? req.connection.encrypted : void 0;\n  const encryptedCheck = _encrypted !== void 0 ? _encrypted === true : void 0;\n  if (encryptedCheck) {\n    return true;\n  }\n  if (protoCheck === void 0 && encryptedCheck === void 0) {\n    return void 0;\n  }\n  return false;\n}\n\nmodule.exports = isHTTPS;\n","import VueMeta from 'vue-meta'\nimport { Constants, options } from './options'\nimport { formatMessage } from './utils-common'\n\n/**\n * @this {import('vue/types/vue').Vue}\n * @param {import('../../types/vue').NuxtI18nHeadOptions} options\n * @return {import('vue-meta').MetaInfo}\n */\nexport function nuxtI18nHead ({ addDirAttribute = false, addSeoAttributes = false } = {}) {\n  // Can happen when using from a global mixin.\n  if (!this.$i18n) {\n    return {}\n  }\n\n  /** @type {import('../../types/vue').NuxtI18nMeta} */\n  const metaObject = {\n    htmlAttrs: {},\n    link: [],\n    meta: []\n  }\n\n  const currentLocale = this.$i18n.localeProperties\n  const currentLocaleIso = currentLocale.iso\n  const currentLocaleDir = currentLocale.dir || options.defaultDirection\n\n  /**\n   * Adding Direction Attribute:\n   */\n  if (addDirAttribute) {\n    metaObject.htmlAttrs.dir = currentLocaleDir\n  }\n\n  /**\n   * Adding SEO Meta:\n   */\n  if (\n    addSeoAttributes &&\n    // @ts-ignore\n    (VueMeta.hasMetaInfo ? VueMeta.hasMetaInfo(this) : this._hasMetaInfo) &&\n    this.$i18n.locale &&\n    this.$i18n.locales\n  ) {\n    if (currentLocaleIso) {\n      metaObject.htmlAttrs.lang = currentLocaleIso // TODO: simple lang or \"specific\" lang with territory?\n    }\n\n    const locales = /** @type {import('../../types').LocaleObject[]} */(this.$i18n.locales)\n\n    addHreflangLinks.bind(this)(locales, this.$i18n.__baseUrl, metaObject.link)\n    addCanonicalLinks.bind(this)(this.$i18n.__baseUrl, metaObject.link, addSeoAttributes)\n    addCurrentOgLocale.bind(this)(currentLocale, currentLocaleIso, metaObject.meta)\n    addAlternateOgLocales.bind(this)(locales, currentLocaleIso, metaObject.meta)\n  }\n\n  /**\n   * Internals:\n   */\n\n  /**\n   * @this {import('vue/types/vue').Vue}\n   *\n   * @param {import('../../types').LocaleObject[]} locales\n   * @param {string} baseUrl\n   * @param {import('../../types/vue').NuxtI18nMeta['link']} link\n   */\n  function addHreflangLinks (locales, baseUrl, link) {\n    if (options.strategy === Constants.STRATEGIES.NO_PREFIX) {\n      return\n    }\n    /** @type {Map<string, import('../../types').LocaleObject>} */\n    const localeMap = new Map()\n    for (const locale of locales) {\n      const localeIso = locale.iso\n\n      if (!localeIso) {\n        // eslint-disable-next-line no-console\n        console.warn(formatMessage('Locale ISO code is required to generate alternate link'))\n        continue\n      }\n\n      const [language, region] = localeIso.split('-')\n\n      if (language && region && (locale.isCatchallLocale || !localeMap.has(language))) {\n        localeMap.set(language, locale)\n      }\n\n      localeMap.set(localeIso, locale)\n    }\n\n    for (const [iso, mapLocale] of localeMap.entries()) {\n      const localePath = this.switchLocalePath(mapLocale.code)\n      if (localePath) {\n        link.push({\n          hid: `i18n-alt-${iso}`,\n          rel: 'alternate',\n          href: toAbsoluteUrl(localePath, baseUrl),\n          hreflang: iso\n        })\n      }\n    }\n\n    if (options.defaultLocale) {\n      const localePath = this.switchLocalePath(options.defaultLocale)\n      if (localePath) {\n        link.push({\n          hid: 'i18n-xd',\n          rel: 'alternate',\n          href: toAbsoluteUrl(localePath, baseUrl),\n          hreflang: 'x-default'\n        })\n      }\n    }\n  }\n\n  /**\n   * @this {import('vue/types/vue').Vue}\n   *\n   * @param {string} baseUrl\n   * @param {import('../../types/vue').NuxtI18nMeta['link']} link\n   * @param {NonNullable<import('../../types/vue').NuxtI18nHeadOptions['addSeoAttributes']>} seoAttributesOptions\n   */\n  function addCanonicalLinks (baseUrl, link, seoAttributesOptions) {\n    const currentRoute = this.localeRoute({\n      ...this.$route,\n      name: this.getRouteBaseName()\n    })\n\n    if (currentRoute) {\n      let href = toAbsoluteUrl(currentRoute.path, baseUrl)\n\n      const canonicalQueries = (typeof (seoAttributesOptions) !== 'boolean' && seoAttributesOptions.canonicalQueries) || []\n\n      if (canonicalQueries.length) {\n        const currentRouteQueryParams = currentRoute.query\n        const params = new URLSearchParams()\n        for (const queryParamName of canonicalQueries) {\n          if (queryParamName in currentRouteQueryParams) {\n            const queryParamValue = currentRouteQueryParams[queryParamName]\n\n            if (Array.isArray(queryParamValue)) {\n              queryParamValue.forEach(v => params.append(queryParamName, v || ''))\n            } else {\n              params.append(queryParamName, queryParamValue || '')\n            }\n          }\n        }\n\n        const queryString = params.toString()\n\n        if (queryString) {\n          href = `${href}?${queryString}`\n        }\n      }\n\n      link.push({\n        hid: 'i18n-can',\n        rel: 'canonical',\n        href\n      })\n    }\n  }\n\n  /**\n   * @this {import('vue/types/vue').Vue}\n   *\n   * @param {import('../../types').LocaleObject} currentLocale\n   * @param {string | undefined} currentLocaleIso\n   * @param {import('../../types/vue').NuxtI18nMeta['meta']} meta\n   */\n  function addCurrentOgLocale (currentLocale, currentLocaleIso, meta) {\n    const hasCurrentLocaleAndIso = currentLocale && currentLocaleIso\n\n    if (!hasCurrentLocaleAndIso) {\n      return\n    }\n\n    meta.push({\n      hid: 'i18n-og',\n      property: 'og:locale',\n      // Replace dash with underscore as defined in spec: language_TERRITORY\n      content: hypenToUnderscore(currentLocaleIso)\n    })\n  }\n\n  /**\n   * @this {import('vue/types/vue').Vue}\n   *\n   * @param {import('../../types').LocaleObject[]} locales\n   * @param {string | undefined} currentLocaleIso\n   * @param {import('../../types/vue').NuxtI18nMeta['meta']} meta\n   */\n  function addAlternateOgLocales (locales, currentLocaleIso, meta) {\n    const localesWithoutCurrent = locales.filter(locale => {\n      const localeIso = locale.iso\n      return localeIso && localeIso !== currentLocaleIso\n    })\n\n    if (localesWithoutCurrent.length) {\n      const alternateLocales = localesWithoutCurrent.map(locale => ({\n        hid: `i18n-og-alt-${locale.iso}`,\n        property: 'og:locale:alternate',\n        content: hypenToUnderscore(locale.iso)\n      }))\n\n      meta.push(...alternateLocales)\n    }\n  }\n\n  /**\n   * @param {string | undefined} str\n   * @return {string}\n   */\n  function hypenToUnderscore (str) {\n    return (str || '').replace(/-/g, '_')\n  }\n\n  /**\n   * @param {string} urlOrPath\n   * @param {string} baseUrl\n   */\n  function toAbsoluteUrl (urlOrPath, baseUrl) {\n    if (urlOrPath.match(/^https?:\\/\\//)) {\n      return urlOrPath\n    }\n    return baseUrl + urlOrPath\n  }\n\n  return metaObject\n}\n","'use strict';\n\nfunction isObject(val) {\n  return val !== null && typeof val === \"object\";\n}\nfunction _defu(baseObj, defaults, namespace = \".\", merger) {\n  if (!isObject(defaults)) {\n    return _defu(baseObj, {}, namespace, merger);\n  }\n  const obj = Object.assign({}, defaults);\n  for (const key in baseObj) {\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const val = baseObj[key];\n    if (val === null || val === void 0) {\n      continue;\n    }\n    if (merger && merger(obj, key, val, namespace)) {\n      continue;\n    }\n    if (Array.isArray(val) && Array.isArray(obj[key])) {\n      obj[key] = obj[key].concat(val);\n    } else if (isObject(val) && isObject(obj[key])) {\n      obj[key] = _defu(val, obj[key], (namespace ? `${namespace}.` : \"\") + key.toString(), merger);\n    } else {\n      obj[key] = val;\n    }\n  }\n  return obj;\n}\nfunction extend(merger) {\n  return (...args) => args.reduce((p, c) => _defu(p, c, \"\", merger), {});\n}\nconst defu = extend();\ndefu.fn = extend((obj, key, currentValue, _namespace) => {\n  if (typeof obj[key] !== \"undefined\" && typeof currentValue === \"function\") {\n    obj[key] = currentValue(obj[key]);\n    return true;\n  }\n});\ndefu.arrayFn = extend((obj, key, currentValue, _namespace) => {\n  if (Array.isArray(obj[key]) && typeof currentValue === \"function\") {\n    obj[key] = currentValue(obj[key]);\n    return true;\n  }\n});\ndefu.extend = extend;\n\nmodule.exports = defu;\n","global.installComponents = function (component, components) {\n  var options = typeof component.exports === 'function'\n    ? component.exports.extendOptions\n    : component.options\n\n  if (typeof component.exports === 'function') {\n    options.components = component.exports.options.components\n  }\n\n  options.components = options.components || {}\n\n  for (var i in components) {\n    options.components[i] = options.components[i] || components[i]\n  }\n\n\n  if (options.functional) {\n    provideFunctionalComponents(component, options.components)\n  }\n}\n\nvar functionalPatchKey = '_functionalComponents'\n\nfunction provideFunctionalComponents(component, components) {\n  if (component.exports[functionalPatchKey]) {\n    return\n  }\n  component.exports[functionalPatchKey] = true\n\n  var render = component.exports.render\n  component.exports.render = function (h, vm) {\n    return render(h, Object.assign({}, vm, {\n      _c: function (n, a, b) {\n        return vm._c(components[n] || n, a, b)\n      }\n    }))\n  }\n}\n","export * from \"-!../../node_modules/css-loader/dist/cjs.js??ref--3-oneOf-1-0!../../node_modules/vue-loader/lib/loaders/stylePostLoader.js!../../node_modules/postcss-loader/dist/cjs.js??ref--3-oneOf-1-1!../../node_modules/@nuxt/components/dist/loader.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./nuxt-loading.vue?vue&type=style&index=0&id=b64bf7b2&prod&lang=css&\"","// Exports\nmodule.exports = {\n\n};\n","module.exports = require(\"js-cookie\");","module.exports = require(\"core-js/modules/esnext.map.delete-all.js\");","module.exports = require(\"core-js/modules/esnext.map.every.js\");","module.exports = require(\"core-js/modules/esnext.map.filter.js\");","module.exports = require(\"core-js/modules/esnext.map.find.js\");","module.exports = require(\"core-js/modules/esnext.map.find-key.js\");","module.exports = require(\"core-js/modules/esnext.map.includes.js\");","module.exports = require(\"core-js/modules/esnext.map.key-of.js\");","module.exports = require(\"core-js/modules/esnext.map.map-keys.js\");","module.exports = require(\"core-js/modules/esnext.map.map-values.js\");","module.exports = require(\"core-js/modules/esnext.map.merge.js\");","module.exports = require(\"core-js/modules/esnext.map.reduce.js\");","module.exports = require(\"core-js/modules/esnext.map.some.js\");","module.exports = require(\"core-js/modules/esnext.map.update.js\");","const middleware = {}\n\nexport default middleware\n","import Vue from 'vue'\nimport { isSamePath as _isSamePath, joinURL, normalizeURL, withQuery, withoutTrailingSlash } from 'ufo'\n\n// window.{{globals.loadedCallback}} hook\n// Useful for jsdom testing or plugins (https://github.com/tmpvar/jsdom#dealing-with-asynchronous-script-loading)\nif (process.client) {\n  window.onNuxtReadyCbs = []\n  window.onNuxtReady = (cb) => {\n    window.onNuxtReadyCbs.push(cb)\n  }\n}\n\nexport function createGetCounter (counterObject, defaultKey = '') {\n  return function getCounter (id = defaultKey) {\n    if (counterObject[id] === undefined) {\n      counterObject[id] = 0\n    }\n    return counterObject[id]++\n  }\n}\n\nexport function empty () {}\n\nexport function globalHandleError (error) {\n  if (Vue.config.errorHandler) {\n    Vue.config.errorHandler(error)\n  }\n}\n\nexport function interopDefault (promise) {\n  return promise.then(m => m.default || m)\n}\n\nexport function hasFetch(vm) {\n  return vm.$options && typeof vm.$options.fetch === 'function' && !vm.$options.fetch.length\n}\nexport function purifyData(data) {\n  if (process.env.NODE_ENV === 'production') {\n    return data\n  }\n\n  return Object.entries(data).filter(\n    ([key, value]) => {\n      const valid = !(value instanceof Function) && !(value instanceof Promise)\n      if (!valid) {\n        console.warn(`${key} is not able to be stringified. This will break in a production environment.`)\n      }\n      return valid\n    }\n    ).reduce((obj, [key, value]) => {\n      obj[key] = value\n      return obj\n    }, {})\n}\nexport function getChildrenComponentInstancesUsingFetch(vm, instances = []) {\n  const children = vm.$children || []\n  for (const child of children) {\n    if (child.$fetch) {\n      instances.push(child)\n    }\n    if (child.$children) {\n      getChildrenComponentInstancesUsingFetch(child, instances)\n    }\n  }\n  return instances\n}\n\nexport function applyAsyncData (Component, asyncData) {\n  if (\n    // For SSR, we once all this function without second param to just apply asyncData\n    // Prevent doing this for each SSR request\n    !asyncData && Component.options.__hasNuxtData\n  ) {\n    return\n  }\n\n  const ComponentData = Component.options._originDataFn || Component.options.data || function () { return {} }\n  Component.options._originDataFn = ComponentData\n\n  Component.options.data = function () {\n    const data = ComponentData.call(this, this)\n    if (this.$ssrContext) {\n      asyncData = this.$ssrContext.asyncData[Component.cid]\n    }\n    return { ...data, ...asyncData }\n  }\n\n  Component.options.__hasNuxtData = true\n\n  if (Component._Ctor && Component._Ctor.options) {\n    Component._Ctor.options.data = Component.options.data\n  }\n}\n\nexport function sanitizeComponent (Component) {\n  // If Component already sanitized\n  if (Component.options && Component._Ctor === Component) {\n    return Component\n  }\n  if (!Component.options) {\n    Component = Vue.extend(Component) // fix issue #6\n    Component._Ctor = Component\n  } else {\n    Component._Ctor = Component\n    Component.extendOptions = Component.options\n  }\n  // If no component name defined, set file path as name, (also fixes #5703)\n  if (!Component.options.name && Component.options.__file) {\n    Component.options.name = Component.options.__file\n  }\n  return Component\n}\n\nexport function getMatchedComponents (route, matches = false, prop = 'components') {\n  return Array.prototype.concat.apply([], route.matched.map((m, index) => {\n    return Object.keys(m[prop]).map((key) => {\n      matches && matches.push(index)\n      return m[prop][key]\n    })\n  }))\n}\n\nexport function getMatchedComponentsInstances (route, matches = false) {\n  return getMatchedComponents(route, matches, 'instances')\n}\n\nexport function flatMapComponents (route, fn) {\n  return Array.prototype.concat.apply([], route.matched.map((m, index) => {\n    return Object.keys(m.components).reduce((promises, key) => {\n      if (m.components[key]) {\n        promises.push(fn(m.components[key], m.instances[key], m, key, index))\n      } else {\n        delete m.components[key]\n      }\n      return promises\n    }, [])\n  }))\n}\n\nexport function resolveRouteComponents (route, fn) {\n  return Promise.all(\n    flatMapComponents(route, async (Component, instance, match, key) => {\n      // If component is a function, resolve it\n      if (typeof Component === 'function' && !Component.options) {\n        try {\n          Component = await Component()\n        } catch (error) {\n          // Handle webpack chunk loading errors\n          // This may be due to a new deployment or a network problem\n          if (\n            error &&\n            error.name === 'ChunkLoadError' &&\n            typeof window !== 'undefined' &&\n            window.sessionStorage\n          ) {\n            const timeNow = Date.now()\n            const previousReloadTime = parseInt(window.sessionStorage.getItem('nuxt-reload'))\n\n            // check for previous reload time not to reload infinitely\n            if (!previousReloadTime || previousReloadTime + 60000 < timeNow) {\n              window.sessionStorage.setItem('nuxt-reload', timeNow)\n              window.location.reload(true /* skip cache */)\n            }\n          }\n\n          throw error\n        }\n      }\n      match.components[key] = Component = sanitizeComponent(Component)\n      return typeof fn === 'function' ? fn(Component, instance, match, key) : Component\n    })\n  )\n}\n\nexport async function getRouteData (route) {\n  if (!route) {\n    return\n  }\n  // Make sure the components are resolved (code-splitting)\n  await resolveRouteComponents(route)\n  // Send back a copy of route with meta based on Component definition\n  return {\n    ...route,\n    meta: getMatchedComponents(route).map((Component, index) => {\n      return { ...Component.options.meta, ...(route.matched[index] || {}).meta }\n    })\n  }\n}\n\nexport async function setContext (app, context) {\n  // If context not defined, create it\n  if (!app.context) {\n    app.context = {\n      isStatic: process.static,\n      isDev: false,\n      isHMR: false,\n      app,\n\n      payload: context.payload,\n      error: context.error,\n      base: app.router.options.base,\n      env: {}\n    }\n    // Only set once\n\n    if (context.req) {\n      app.context.req = context.req\n    }\n    if (context.res) {\n      app.context.res = context.res\n    }\n\n    if (context.ssrContext) {\n      app.context.ssrContext = context.ssrContext\n    }\n    app.context.redirect = (status, path, query) => {\n      if (!status) {\n        return\n      }\n      app.context._redirected = true\n      // if only 1 or 2 arguments: redirect('/') or redirect('/', { foo: 'bar' })\n      let pathType = typeof path\n      if (typeof status !== 'number' && (pathType === 'undefined' || pathType === 'object')) {\n        query = path || {}\n        path = status\n        pathType = typeof path\n        status = 302\n      }\n      if (pathType === 'object') {\n        path = app.router.resolve(path).route.fullPath\n      }\n      // \"/absolute/route\", \"./relative/route\" or \"../relative/route\"\n      if (/(^[.]{1,2}\\/)|(^\\/(?!\\/))/.test(path)) {\n        app.context.next({\n          path,\n          query,\n          status\n        })\n      } else {\n        path = withQuery(path, query)\n        if (process.server) {\n          app.context.next({\n            path,\n            status\n          })\n        }\n        if (process.client) {\n          // https://developer.mozilla.org/en-US/docs/Web/API/Location/assign\n          window.location.assign(path)\n\n          // Throw a redirect error\n          throw new Error('ERR_REDIRECT')\n        }\n      }\n    }\n    if (process.server) {\n      app.context.beforeNuxtRender = fn => context.beforeRenderFns.push(fn)\n      app.context.beforeSerialize = fn => context.beforeSerializeFns.push(fn)\n    }\n    if (process.client) {\n      app.context.nuxtState = window.__NUXT__\n    }\n  }\n\n  // Dynamic keys\n  const [currentRouteData, fromRouteData] = await Promise.all([\n    getRouteData(context.route),\n    getRouteData(context.from)\n  ])\n\n  if (context.route) {\n    app.context.route = currentRouteData\n  }\n\n  if (context.from) {\n    app.context.from = fromRouteData\n  }\n\n  app.context.next = context.next\n  app.context._redirected = false\n  app.context._errored = false\n  app.context.isHMR = false\n  app.context.params = app.context.route.params || {}\n  app.context.query = app.context.route.query || {}\n}\n\nexport function middlewareSeries (promises, appContext) {\n  if (!promises.length || appContext._redirected || appContext._errored) {\n    return Promise.resolve()\n  }\n  return promisify(promises[0], appContext)\n    .then(() => {\n      return middlewareSeries(promises.slice(1), appContext)\n    })\n}\n\nexport function promisify (fn, context) {\n  let promise\n  if (fn.length === 2) {\n    // fn(context, callback)\n    promise = new Promise((resolve) => {\n      fn(context, function (err, data) {\n        if (err) {\n          context.error(err)\n        }\n        data = data || {}\n        resolve(data)\n      })\n    })\n  } else {\n    promise = fn(context)\n  }\n\n  if (promise && promise instanceof Promise && typeof promise.then === 'function') {\n    return promise\n  }\n  return Promise.resolve(promise)\n}\n\n// Imported from vue-router\nexport function getLocation (base, mode) {\n  if (mode === 'hash') {\n    return window.location.hash.replace(/^#\\//, '')\n  }\n\n  base = decodeURI(base).slice(0, -1) // consideration is base is normalized with trailing slash\n  let path = decodeURI(window.location.pathname)\n\n  if (base && path.startsWith(base)) {\n    path = path.slice(base.length)\n  }\n\n  const fullPath = (path || '/') + window.location.search + window.location.hash\n\n  return normalizeURL(fullPath)\n}\n\n// Imported from path-to-regexp\n\n/**\n * Compile a string to a template function for the path.\n *\n * @param  {string}             str\n * @param  {Object=}            options\n * @return {!function(Object=, Object=)}\n */\nexport function compile (str, options) {\n  return tokensToFunction(parse(str, options), options)\n}\n\nexport function getQueryDiff (toQuery, fromQuery) {\n  const diff = {}\n  const queries = { ...toQuery, ...fromQuery }\n  for (const k in queries) {\n    if (String(toQuery[k]) !== String(fromQuery[k])) {\n      diff[k] = true\n    }\n  }\n  return diff\n}\n\nexport function normalizeError (err) {\n  let message\n  if (!(err.message || typeof err === 'string')) {\n    try {\n      message = JSON.stringify(err, null, 2)\n    } catch (e) {\n      message = `[${err.constructor.name}]`\n    }\n  } else {\n    message = err.message || err\n  }\n  return {\n    ...err,\n    message,\n    statusCode: (err.statusCode || err.status || (err.response && err.response.status) || 500)\n  }\n}\n\n/**\n * The main path matching regexp utility.\n *\n * @type {RegExp}\n */\nconst PATH_REGEXP = new RegExp([\n  // Match escaped characters that would otherwise appear in future matches.\n  // This allows the user to escape special characters that won't transform.\n  '(\\\\\\\\.)',\n  // Match Express-style parameters and un-named parameters with a prefix\n  // and optional suffixes. Matches appear as:\n  //\n  // \"/:test(\\\\d+)?\" => [\"/\", \"test\", \"\\d+\", undefined, \"?\", undefined]\n  // \"/route(\\\\d+)\"  => [undefined, undefined, undefined, \"\\d+\", undefined, undefined]\n  // \"/*\"            => [\"/\", undefined, undefined, undefined, undefined, \"*\"]\n  '([\\\\/.])?(?:(?:\\\\:(\\\\w+)(?:\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))?|\\\\(((?:\\\\\\\\.|[^\\\\\\\\()])+)\\\\))([+*?])?|(\\\\*))'\n].join('|'), 'g')\n\n/**\n * Parse a string for the raw tokens.\n *\n * @param  {string}  str\n * @param  {Object=} options\n * @return {!Array}\n */\nfunction parse (str, options) {\n  const tokens = []\n  let key = 0\n  let index = 0\n  let path = ''\n  const defaultDelimiter = (options && options.delimiter) || '/'\n  let res\n\n  while ((res = PATH_REGEXP.exec(str)) != null) {\n    const m = res[0]\n    const escaped = res[1]\n    const offset = res.index\n    path += str.slice(index, offset)\n    index = offset + m.length\n\n    // Ignore already escaped sequences.\n    if (escaped) {\n      path += escaped[1]\n      continue\n    }\n\n    const next = str[index]\n    const prefix = res[2]\n    const name = res[3]\n    const capture = res[4]\n    const group = res[5]\n    const modifier = res[6]\n    const asterisk = res[7]\n\n    // Push the current path onto the tokens.\n    if (path) {\n      tokens.push(path)\n      path = ''\n    }\n\n    const partial = prefix != null && next != null && next !== prefix\n    const repeat = modifier === '+' || modifier === '*'\n    const optional = modifier === '?' || modifier === '*'\n    const delimiter = res[2] || defaultDelimiter\n    const pattern = capture || group\n\n    tokens.push({\n      name: name || key++,\n      prefix: prefix || '',\n      delimiter,\n      optional,\n      repeat,\n      partial,\n      asterisk: Boolean(asterisk),\n      pattern: pattern ? escapeGroup(pattern) : (asterisk ? '.*' : '[^' + escapeString(delimiter) + ']+?')\n    })\n  }\n\n  // Match any characters still remaining.\n  if (index < str.length) {\n    path += str.substr(index)\n  }\n\n  // If the path exists, push it onto the end.\n  if (path) {\n    tokens.push(path)\n  }\n\n  return tokens\n}\n\n/**\n * Prettier encoding of URI path segments.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeURIComponentPretty (str, slashAllowed) {\n  const re = slashAllowed ? /[?#]/g : /[/?#]/g\n  return encodeURI(str).replace(re, (c) => {\n    return '%' + c.charCodeAt(0).toString(16).toUpperCase()\n  })\n}\n\n/**\n * Encode the asterisk parameter. Similar to `pretty`, but allows slashes.\n *\n * @param  {string}\n * @return {string}\n */\nfunction encodeAsterisk (str) {\n  return encodeURIComponentPretty(str, true)\n}\n\n/**\n * Escape a regular expression string.\n *\n * @param  {string} str\n * @return {string}\n */\nfunction escapeString (str) {\n  return str.replace(/([.+*?=^!:${}()[\\]|/\\\\])/g, '\\\\$1')\n}\n\n/**\n * Escape the capturing group by escaping special characters and meaning.\n *\n * @param  {string} group\n * @return {string}\n */\nfunction escapeGroup (group) {\n  return group.replace(/([=!:$/()])/g, '\\\\$1')\n}\n\n/**\n * Expose a method for transforming tokens into the path function.\n */\nfunction tokensToFunction (tokens, options) {\n  // Compile all the tokens into regexps.\n  const matches = new Array(tokens.length)\n\n  // Compile all the patterns before compilation.\n  for (let i = 0; i < tokens.length; i++) {\n    if (typeof tokens[i] === 'object') {\n      matches[i] = new RegExp('^(?:' + tokens[i].pattern + ')$', flags(options))\n    }\n  }\n\n  return function (obj, opts) {\n    let path = ''\n    const data = obj || {}\n    const options = opts || {}\n    const encode = options.pretty ? encodeURIComponentPretty : encodeURIComponent\n\n    for (let i = 0; i < tokens.length; i++) {\n      const token = tokens[i]\n\n      if (typeof token === 'string') {\n        path += token\n\n        continue\n      }\n\n      const value = data[token.name || 'pathMatch']\n      let segment\n\n      if (value == null) {\n        if (token.optional) {\n          // Prepend partial segment prefixes.\n          if (token.partial) {\n            path += token.prefix\n          }\n\n          continue\n        } else {\n          throw new TypeError('Expected \"' + token.name + '\" to be defined')\n        }\n      }\n\n      if (Array.isArray(value)) {\n        if (!token.repeat) {\n          throw new TypeError('Expected \"' + token.name + '\" to not repeat, but received `' + JSON.stringify(value) + '`')\n        }\n\n        if (value.length === 0) {\n          if (token.optional) {\n            continue\n          } else {\n            throw new TypeError('Expected \"' + token.name + '\" to not be empty')\n          }\n        }\n\n        for (let j = 0; j < value.length; j++) {\n          segment = encode(value[j])\n\n          if (!matches[i].test(segment)) {\n            throw new TypeError('Expected all \"' + token.name + '\" to match \"' + token.pattern + '\", but received `' + JSON.stringify(segment) + '`')\n          }\n\n          path += (j === 0 ? token.prefix : token.delimiter) + segment\n        }\n\n        continue\n      }\n\n      segment = token.asterisk ? encodeAsterisk(value) : encode(value)\n\n      if (!matches[i].test(segment)) {\n        throw new TypeError('Expected \"' + token.name + '\" to match \"' + token.pattern + '\", but received \"' + segment + '\"')\n      }\n\n      path += token.prefix + segment\n    }\n\n    return path\n  }\n}\n\n/**\n * Get the flags for a regexp from the options.\n *\n * @param  {Object} options\n * @return {string}\n */\nfunction flags (options) {\n  return options && options.sensitive ? '' : 'i'\n}\n\nexport function addLifecycleHook(vm, hook, fn) {\n  if (!vm.$options[hook]) {\n    vm.$options[hook] = []\n  }\n  if (!vm.$options[hook].includes(fn)) {\n    vm.$options[hook].push(fn)\n  }\n}\n\nexport const urlJoin = joinURL\n\nexport const stripTrailingSlash = withoutTrailingSlash\n\nexport const isSamePath = _isSamePath\n\nexport function setScrollRestoration (newVal) {\n  try {\n    window.history.scrollRestoration = newVal;\n  } catch(e) {}\n}\n","import Vue from 'vue'\nimport { hasFetch, normalizeError, addLifecycleHook, purifyData, createGetCounter } from '../utils'\n\nasync function serverPrefetch() {\n  if (!this._fetchOnServer) {\n    return\n  }\n\n  // Call and await on $fetch\n  try {\n    await this.$options.fetch.call(this)\n  } catch (err) {\n    if (process.dev) {\n      console.error('Error in fetch():', err)\n    }\n    this.$fetchState.error = normalizeError(err)\n  }\n  this.$fetchState.pending = false\n\n  // Define an ssrKey for hydration\n  this._fetchKey = this._fetchKey || this.$ssrContext.fetchCounters['']++\n\n  // Add data-fetch-key on parent element of Component\n  const attrs = this.$vnode.data.attrs = this.$vnode.data.attrs || {}\n  attrs['data-fetch-key'] = this._fetchKey\n\n  // Add to ssrContext for window.__NUXT__.fetch\n\n  this.$ssrContext.nuxt.fetch[this._fetchKey] =\n    this.$fetchState.error ? { _error: this.$fetchState.error } : purifyData(this._data)\n}\n\nexport default {\n  created() {\n    if (!hasFetch(this)) {\n      return\n    }\n\n    if (typeof this.$options.fetchOnServer === 'function') {\n      this._fetchOnServer = this.$options.fetchOnServer.call(this) !== false\n    } else {\n      this._fetchOnServer = this.$options.fetchOnServer !== false\n    }\n\n    const defaultKey = this.$options._scopeId || this.$options.name || ''\n    const getCounter = createGetCounter(this.$ssrContext.fetchCounters, defaultKey)\n\n    if (typeof this.$options.fetchKey === 'function') {\n      this._fetchKey = this.$options.fetchKey.call(this, getCounter)\n    } else {\n      const key = 'string' === typeof this.$options.fetchKey ? this.$options.fetchKey : defaultKey\n      this._fetchKey = key ? key + ':' + getCounter(key) : String(getCounter(key))\n    }\n\n    // Added for remove vue undefined warning while ssr\n    this.$fetch = () => {} // issue #8043\n    Vue.util.defineReactive(this, '$fetchState', {\n      pending: true,\n      error: null,\n      timestamp: Date.now()\n    })\n\n    addLifecycleHook(this, 'serverPrefetch', serverPrefetch)\n  }\n}\n","import { getMatchedComponents, setScrollRestoration } from './utils'\n\nif (process.client) {\n  if ('scrollRestoration' in window.history) {\n    setScrollRestoration('manual')\n\n    // reset scrollRestoration to auto when leaving page, allowing page reload\n    // and back-navigation from other pages to use the browser to restore the\n    // scrolling position.\n    window.addEventListener('beforeunload', () => {\n      setScrollRestoration('auto')\n    })\n\n    // Setting scrollRestoration to manual again when returning to this page.\n    window.addEventListener('load', () => {\n      setScrollRestoration('manual')\n    })\n  }\n}\n\nfunction shouldScrollToTop(route) {\n   const Pages = getMatchedComponents(route)\n   if (Pages.length === 1) {\n     const { options = {} } = Pages[0]\n     return options.scrollToTop !== false\n   }\n   return Pages.some(({ options }) => options && options.scrollToTop)\n}\n\nexport default function (to, from, savedPosition) {\n  // If the returned position is falsy or an empty object, will retain current scroll position\n  let position = false\n  const isRouteChanged = to !== from\n\n  // savedPosition is only available for popstate navigations (back button)\n  if (savedPosition) {\n    position = savedPosition\n  } else if (isRouteChanged && shouldScrollToTop(to)) {\n    position = { x: 0, y: 0 }\n  }\n\n  const nuxt = window.$nuxt\n\n  if (\n    // Initial load (vuejs/vue-router#3199)\n    !isRouteChanged ||\n    // Route hash changes\n    (to.path === from.path && to.hash !== from.hash)\n  ) {\n    nuxt.$nextTick(() => nuxt.$emit('triggerScroll'))\n  }\n\n  return new Promise((resolve) => {\n    // wait for the out transition to complete (if necessary)\n    nuxt.$once('triggerScroll', () => {\n      // coords will be used if no selector is provided,\n      // or if the selector didn't match any element.\n      if (to.hash) {\n        let hash = to.hash\n        // CSS.escape() is not supported with IE and Edge.\n        if (typeof window.CSS !== 'undefined' && typeof window.CSS.escape !== 'undefined') {\n          hash = '#' + window.CSS.escape(hash.substr(1))\n        }\n        try {\n          const el = document.querySelector(hash)\n          if (el) {\n            // scroll to anchor by returning the selector\n            position = { selector: hash }\n            // Respect any scroll-margin-top set in CSS when scrolling to anchor\n            const y = Number(getComputedStyle(el)['scroll-margin-top']?.replace('px', ''))\n            if (y) {\n              position.offset = { y }\n            }\n          }\n        } catch (e) {\n          console.warn('Failed to save scroll position. Please add CSS.escape() polyfill (https://github.com/mathiasbynens/CSS.escape).')\n        }\n      }\n      resolve(position)\n    })\n  })\n}\n","import Vue from 'vue'\nimport Router from 'vue-router'\nimport { normalizeURL, decode } from 'ufo'\nimport { interopDefault } from './utils'\nimport scrollBehavior from './router.scrollBehavior.js'\n\nconst _88ada2d8 = () => interopDefault(import('..\\\\pages\\\\inspire.vue' /* webpackChunkName: \"pages/inspire\" */))\nconst _4da96de8 = () => interopDefault(import('..\\\\pages\\\\index.vue' /* webpackChunkName: \"pages/index\" */))\n\nconst emptyFn = () => {}\n\nVue.use(Router)\n\nexport const routerOptions = {\n  mode: 'history',\n  base: '/',\n  linkActiveClass: 'nuxt-link-active',\n  linkExactActiveClass: 'nuxt-link-exact-active',\n  scrollBehavior,\n\n  routes: [{\n    path: \"/inspire\",\n    component: _88ada2d8,\n    name: \"inspire\"\n  }, {\n    path: \"/\",\n    component: _4da96de8,\n    name: \"index\"\n  }],\n\n  fallback: false\n}\n\nexport function createRouter (ssrContext, config) {\n  const base = (config._app && config._app.basePath) || routerOptions.base\n  const router = new Router({ ...routerOptions, base  })\n\n  // TODO: remove in Nuxt 3\n  const originalPush = router.push\n  router.push = function push (location, onComplete = emptyFn, onAbort) {\n    return originalPush.call(this, location, onComplete, onAbort)\n  }\n\n  const resolve = router.resolve.bind(router)\n  router.resolve = (to, current, append) => {\n    if (typeof to === 'string') {\n      to = normalizeURL(to)\n    }\n    return resolve(to, current, append)\n  }\n\n  return router\n}\n","export default {\n  name: 'NuxtChild',\n  functional: true,\n  props: {\n    nuxtChildKey: {\n      type: String,\n      default: ''\n    },\n    keepAlive: Boolean,\n    keepAliveProps: {\n      type: Object,\n      default: undefined\n    }\n  },\n  render (_, { parent, data, props }) {\n    const h = parent.$createElement\n\n    data.nuxtChild = true\n    const _parent = parent\n    const transitions = parent.$nuxt.nuxt.transitions\n    const defaultTransition = parent.$nuxt.nuxt.defaultTransition\n\n    let depth = 0\n    while (parent) {\n      if (parent.$vnode && parent.$vnode.data.nuxtChild) {\n        depth++\n      }\n      parent = parent.$parent\n    }\n    data.nuxtChildDepth = depth\n    const transition = transitions[depth] || defaultTransition\n    const transitionProps = {}\n    transitionsKeys.forEach((key) => {\n      if (typeof transition[key] !== 'undefined') {\n        transitionProps[key] = transition[key]\n      }\n    })\n\n    const listeners = {}\n    listenersKeys.forEach((key) => {\n      if (typeof transition[key] === 'function') {\n        listeners[key] = transition[key].bind(_parent)\n      }\n    })\n    if (process.client) {\n      // Add triggerScroll event on beforeEnter (fix #1376)\n      const beforeEnter = listeners.beforeEnter\n      listeners.beforeEnter = (el) => {\n        // Ensure to trigger scroll event after calling scrollBehavior\n        window.$nuxt.$nextTick(() => {\n          window.$nuxt.$emit('triggerScroll')\n        })\n        if (beforeEnter) {\n          return beforeEnter.call(_parent, el)\n        }\n      }\n    }\n\n    // make sure that leave is called asynchronous (fix #5703)\n    if (transition.css === false) {\n      const leave = listeners.leave\n\n      // only add leave listener when user didnt provide one\n      // or when it misses the done argument\n      if (!leave || leave.length < 2) {\n        listeners.leave = (el, done) => {\n          if (leave) {\n            leave.call(_parent, el)\n          }\n\n          _parent.$nextTick(done)\n        }\n      }\n    }\n\n    let routerView = h('routerView', data)\n\n    if (props.keepAlive) {\n      routerView = h('keep-alive', { props: props.keepAliveProps }, [routerView])\n    }\n\n    return h('transition', {\n      props: transitionProps,\n      on: listeners\n    }, [routerView])\n  }\n}\n\nconst transitionsKeys = [\n  'name',\n  'mode',\n  'appear',\n  'css',\n  'type',\n  'duration',\n  'enterClass',\n  'leaveClass',\n  'appearClass',\n  'enterActiveClass',\n  'enterActiveClass',\n  'leaveActiveClass',\n  'appearActiveClass',\n  'enterToClass',\n  'leaveToClass',\n  'appearToClass'\n]\n\nconst listenersKeys = [\n  'beforeEnter',\n  'enter',\n  'afterEnter',\n  'enterCancelled',\n  'beforeLeave',\n  'leave',\n  'afterLeave',\n  'leaveCancelled',\n  'beforeAppear',\n  'appear',\n  'afterAppear',\n  'appearCancelled'\n]\n","var render = function render(){var _vm=this,_c=_vm._self._c;return _c('div',[_vm._ssrNode(\"error\")])\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","import mod from \"-!../node_modules/babel-loader/lib/index.js??ref--2-0!../node_modules/@nuxt/components/dist/loader.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./error.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../node_modules/babel-loader/lib/index.js??ref--2-0!../node_modules/@nuxt/components/dist/loader.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./error.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./error.vue?vue&type=template&id=ae8307e2&scoped=true&\"\nimport script from \"./error.vue?vue&type=script&lang=js&\"\nexport * from \"./error.vue?vue&type=script&lang=js&\"\nfunction injectStyles (context) {\n  \n  \n}\n\n/* normalize component */\nimport normalizer from \"!../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  injectStyles,\n  \"ae8307e2\",\n  \"561e6757\"\n  \n)\n\nexport default component.exports","import Vue from 'vue'\nimport { compile } from '../utils'\n\nimport NuxtError from '../..\\\\layouts\\\\error.vue'\n\nimport NuxtChild from './nuxt-child'\n\nexport default {\n  name: 'Nuxt',\n  components: {\n    NuxtChild,\n    NuxtError\n  },\n  props: {\n    nuxtChildKey: {\n      type: String,\n      default: undefined\n    },\n    keepAlive: Boolean,\n    keepAliveProps: {\n      type: Object,\n      default: undefined\n    },\n    name: {\n      type: String,\n      default: 'default'\n    }\n  },\n  errorCaptured (error) {\n    // if we receive and error while showing the NuxtError component\n    // capture the error and force an immediate update so we re-render\n    // without the NuxtError component\n    if (this.displayingNuxtError) {\n      this.errorFromNuxtError = error\n      this.$forceUpdate()\n    }\n  },\n  computed: {\n    routerViewKey () {\n      // If nuxtChildKey prop is given or current route has children\n      if (typeof this.nuxtChildKey !== 'undefined' || this.$route.matched.length > 1) {\n        return this.nuxtChildKey || compile(this.$route.matched[0].path)(this.$route.params)\n      }\n\n      const [matchedRoute] = this.$route.matched\n\n      if (!matchedRoute) {\n        return this.$route.path\n      }\n\n      const Component = matchedRoute.components.default\n\n      if (Component && Component.options) {\n        const { options } = Component\n\n        if (options.key) {\n          return (typeof options.key === 'function' ? options.key(this.$route) : options.key)\n        }\n      }\n\n      const strict = /\\/$/.test(matchedRoute.path)\n      return strict ? this.$route.path : this.$route.path.replace(/\\/$/, '')\n    }\n  },\n  beforeCreate () {\n    Vue.util.defineReactive(this, 'nuxt', this.$root.$options.nuxt)\n  },\n  render (h) {\n    // if there is no error\n    if (!this.nuxt.err) {\n      // Directly return nuxt child\n      return h('NuxtChild', {\n        key: this.routerViewKey,\n        props: this.$props\n      })\n    }\n\n    // if an error occurred within NuxtError show a simple\n    // error message instead to prevent looping\n    if (this.errorFromNuxtError) {\n      this.$nextTick(() => (this.errorFromNuxtError = false))\n\n      return h('div', {}, [\n        h('h2', 'An error occurred while showing the error page'),\n        h('p', 'Unfortunately an error occurred and while showing the error page another error occurred'),\n        h('p', `Error details: ${this.errorFromNuxtError.toString()}`),\n        h('nuxt-link', { props: { to: '/' } }, 'Go back to home')\n      ])\n    }\n\n    // track if we are showing the NuxtError component\n    this.displayingNuxtError = true\n    this.$nextTick(() => (this.displayingNuxtError = false))\n\n    return h(NuxtError, {\n      props: {\n        error: this.nuxt.err\n      }\n    })\n  }\n}\n","\nexport default {\n  name: 'NuxtLoading',\n  data () {\n    return {\n      percent: 0,\n      show: false,\n      canSucceed: true,\n      reversed: false,\n      skipTimerCount: 0,\n      rtl: false,\n      throttle: 200,\n      duration: 5000,\n      continuous: false\n    }\n  },\n  computed: {\n    left () {\n      if (!this.continuous && !this.rtl) {\n        return false\n      }\n      return this.rtl\n        ? (this.reversed ? '0px' : 'auto')\n        : (!this.reversed ? '0px' : 'auto')\n    }\n  },\n  beforeDestroy () {\n    this.clear()\n  },\n  methods: {\n    clear () {\n      clearInterval(this._timer)\n      clearTimeout(this._throttle)\n      clearTimeout(this._hide)\n      this._timer = null\n    },\n    start () {\n      this.clear()\n      this.percent = 0\n      this.reversed = false\n      this.skipTimerCount = 0\n      this.canSucceed = true\n\n      if (this.throttle) {\n        this._throttle = setTimeout(() => this.startTimer(), this.throttle)\n      } else {\n        this.startTimer()\n      }\n      return this\n    },\n    set (num) {\n      this.show = true\n      this.canSucceed = true\n      this.percent = Math.min(100, Math.max(0, Math.floor(num)))\n      return this\n    },\n    get () {\n      return this.percent\n    },\n    increase (num) {\n      this.percent = Math.min(100, Math.floor(this.percent + num))\n      return this\n    },\n    decrease (num) {\n      this.percent = Math.max(0, Math.floor(this.percent - num))\n      return this\n    },\n    pause () {\n      clearInterval(this._timer)\n      return this\n    },\n    resume () {\n      this.startTimer()\n      return this\n    },\n    finish () {\n      this.percent = this.reversed ? 0 : 100\n      this.hide()\n      return this\n    },\n    hide () {\n      this.clear()\n      this._hide = setTimeout(() => {\n        this.show = false\n        this.$nextTick(() => {\n          this.percent = 0\n          this.reversed = false\n        })\n      }, 500)\n      return this\n    },\n    fail (error) {\n      this.canSucceed = false\n      return this\n    },\n    startTimer () {\n      if (!this.show) {\n        this.show = true\n      }\n      if (typeof this._cut === 'undefined') {\n        this._cut = 10000 / Math.floor(this.duration)\n      }\n\n      this._timer = setInterval(() => {\n        /**\n         * When reversing direction skip one timers\n         * so 0, 100 are displayed for two iterations\n         * also disable css width transitioning\n         * which otherwise interferes and shows\n         * a jojo effect\n         */\n        if (this.skipTimerCount > 0) {\n          this.skipTimerCount--\n          return\n        }\n\n        if (this.reversed) {\n          this.decrease(this._cut)\n        } else {\n          this.increase(this._cut)\n        }\n\n        if (this.continuous) {\n          if (this.percent >= 100) {\n            this.skipTimerCount = 1\n\n            this.reversed = !this.reversed\n          } else if (this.percent <= 0) {\n            this.skipTimerCount = 1\n\n            this.reversed = !this.reversed\n          }\n        }\n      }, 100)\n    }\n  },\n  render (h) {\n    let el = h(false)\n    if (this.show) {\n      el = h('div', {\n        staticClass: 'nuxt-progress',\n        class: {\n          'nuxt-progress-notransition': this.skipTimerCount > 0,\n          'nuxt-progress-failed': !this.canSucceed\n        },\n        style: {\n          width: this.percent + '%',\n          left: this.left\n        }\n      })\n    }\n    return el\n  }\n}\n","import mod from \"-!../../node_modules/babel-loader/lib/index.js??ref--2-0!../../node_modules/@nuxt/components/dist/loader.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./nuxt-loading.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../node_modules/babel-loader/lib/index.js??ref--2-0!../../node_modules/@nuxt/components/dist/loader.js??ref--0-0!../../node_modules/vue-loader/lib/index.js??vue-loader-options!./nuxt-loading.vue?vue&type=script&lang=js&\"","var render, staticRenderFns\nimport script from \"./nuxt-loading.vue?vue&type=script&lang=js&\"\nexport * from \"./nuxt-loading.vue?vue&type=script&lang=js&\"\nfunction injectStyles (context) {\n  \n  var style0 = require(\"./nuxt-loading.vue?vue&type=style&index=0&id=b64bf7b2&prod&lang=css&\")\nif (style0.__inject__) style0.__inject__(context)\n\n}\n\n/* normalize component */\nimport normalizer from \"!../../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  injectStyles,\n  null,\n  \"5c3a912f\"\n  \n)\n\nexport default component.exports","var render = function render(){var _vm=this,_c=_vm._self._c;return _c('div',[_vm._ssrNode(\"default\")])\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","import mod from \"-!../node_modules/babel-loader/lib/index.js??ref--2-0!../node_modules/@nuxt/components/dist/loader.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./default.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../node_modules/babel-loader/lib/index.js??ref--2-0!../node_modules/@nuxt/components/dist/loader.js??ref--0-0!../node_modules/vue-loader/lib/index.js??vue-loader-options!./default.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./default.vue?vue&type=template&id=081b088a&\"\nimport script from \"./default.vue?vue&type=script&lang=js&\"\nexport * from \"./default.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../node_modules/vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  \"9b805560\"\n  \n)\n\nexport default component.exports","import Vue from 'vue'\nimport { decode, parsePath, withoutBase, withoutTrailingSlash, normalizeURL } from 'ufo'\n\nimport { getMatchedComponentsInstances, getChildrenComponentInstancesUsingFetch, promisify, globalHandleError, urlJoin, sanitizeComponent } from './utils'\nimport NuxtError from '..\\\\layouts\\\\error.vue'\nimport NuxtLoading from './components/nuxt-loading.vue'\n\nimport _6f6c098b from '..\\\\layouts\\\\default.vue'\n\nconst layouts = { \"_default\": sanitizeComponent(_6f6c098b) }\n\nexport default {\n  render (h, props) {\n    const loadingEl = h('NuxtLoading', { ref: 'loading' })\n\n    const layoutEl = h(this.layout || 'nuxt')\n    const templateEl = h('div', {\n      domProps: {\n        id: '__layout'\n      },\n      key: this.layoutName\n    }, [layoutEl])\n\n    const transitionEl = h('transition', {\n      props: {\n        name: 'layout',\n        mode: 'out-in'\n      },\n      on: {\n        beforeEnter (el) {\n          // Ensure to trigger scroll event after calling scrollBehavior\n          window.$nuxt.$nextTick(() => {\n            window.$nuxt.$emit('triggerScroll')\n          })\n        }\n      }\n    }, [templateEl])\n\n    return h('div', {\n      domProps: {\n        id: '__nuxt'\n      }\n    }, [\n      loadingEl,\n\n      transitionEl\n    ])\n  },\n\n  data: () => ({\n    isOnline: true,\n\n    layout: null,\n    layoutName: '',\n\n    nbFetching: 0\n    }),\n\n  beforeCreate () {\n    Vue.util.defineReactive(this, 'nuxt', this.$options.nuxt)\n  },\n  created () {\n    // Add this.$nuxt in child instances\n    this.$root.$options.$nuxt = this\n\n    if (process.client) {\n      // add to window so we can listen when ready\n      window.$nuxt = this\n\n      this.refreshOnlineStatus()\n      // Setup the listeners\n      window.addEventListener('online', this.refreshOnlineStatus)\n      window.addEventListener('offline', this.refreshOnlineStatus)\n    }\n    // Add $nuxt.error()\n    this.error = this.nuxt.error\n    // Add $nuxt.context\n    this.context = this.$options.context\n  },\n\n  async mounted () {\n    this.$loading = this.$refs.loading\n  },\n\n  watch: {\n    'nuxt.err': 'errorChanged'\n  },\n\n  computed: {\n    isOffline () {\n      return !this.isOnline\n    },\n\n    isFetching () {\n      return this.nbFetching > 0\n    },\n  },\n\n  methods: {\n    refreshOnlineStatus () {\n      if (process.client) {\n        if (typeof window.navigator.onLine === 'undefined') {\n          // If the browser doesn't support connection status reports\n          // assume that we are online because most apps' only react\n          // when they now that the connection has been interrupted\n          this.isOnline = true\n        } else {\n          this.isOnline = window.navigator.onLine\n        }\n      }\n    },\n\n    async refresh () {\n      const pages = getMatchedComponentsInstances(this.$route)\n\n      if (!pages.length) {\n        return\n      }\n      this.$loading.start()\n\n      const promises = pages.map(async (page) => {\n        let p = []\n\n        // Old fetch\n        if (page.$options.fetch && page.$options.fetch.length) {\n          p.push(promisify(page.$options.fetch, this.context))\n        }\n\n        if (page.$options.asyncData) {\n          p.push(\n            promisify(page.$options.asyncData, this.context)\n              .then((newData) => {\n                for (const key in newData) {\n                  Vue.set(page.$data, key, newData[key])\n                }\n              })\n          )\n        }\n\n        // Wait for asyncData & old fetch to finish\n        await Promise.all(p)\n        // Cleanup refs\n        p = []\n\n        if (page.$fetch) {\n          p.push(page.$fetch())\n        }\n        // Get all component instance to call $fetch\n        for (const component of getChildrenComponentInstancesUsingFetch(page.$vnode.componentInstance)) {\n          p.push(component.$fetch())\n        }\n\n        return Promise.all(p)\n      })\n      try {\n        await Promise.all(promises)\n      } catch (error) {\n        this.$loading.fail(error)\n        globalHandleError(error)\n        this.error(error)\n      }\n      this.$loading.finish()\n    },\n    errorChanged () {\n      if (this.nuxt.err) {\n        if (this.$loading) {\n          if (this.$loading.fail) {\n            this.$loading.fail(this.nuxt.err)\n          }\n          if (this.$loading.finish) {\n            this.$loading.finish()\n          }\n        }\n\n        let errorLayout = (NuxtError.options || NuxtError).layout;\n\n        if (typeof errorLayout === 'function') {\n          errorLayout = errorLayout(this.context)\n        }\n\n        this.setLayout(errorLayout)\n      }\n    },\n\n    setLayout (layout) {\n      if (!layout || !layouts['_' + layout]) {\n        layout = 'default'\n      }\n      this.layoutName = layout\n      this.layout = layouts['_' + layout]\n      return this.layout\n    },\n    loadLayout (layout) {\n      if (!layout || !layouts['_' + layout]) {\n        layout = 'default'\n      }\n      return Promise.resolve(layouts['_' + layout])\n    },\n  },\n\n  components: {\n    NuxtLoading\n  }\n}\n","export const NuxtLogo = () => import('../..\\\\components\\\\NuxtLogo.vue' /* webpackChunkName: \"components/nuxt-logo\" */).then(c => wrapFunctional(c.default || c))\nexport const Tutorial = () => import('../..\\\\components\\\\Tutorial.vue' /* webpackChunkName: \"components/tutorial\" */).then(c => wrapFunctional(c.default || c))\nexport const VuetifyLogo = () => import('../..\\\\components\\\\VuetifyLogo.vue' /* webpackChunkName: \"components/vuetify-logo\" */).then(c => wrapFunctional(c.default || c))\n\n// nuxt/nuxt.js#8607\nfunction wrapFunctional(options) {\n  if (!options || !options.functional) {\n    return options\n  }\n\n  const propKeys = Array.isArray(options.props) ? options.props : Object.keys(options.props || {})\n\n  return {\n    render(h) {\n      const attrs = {}\n      const props = {}\n\n      for (const key in this.$attrs) {\n        if (propKeys.includes(key)) {\n          props[key] = this.$attrs[key]\n        } else {\n          attrs[key] = this.$attrs[key]\n        }\n      }\n\n      return h(options, {\n        on: this.$listeners,\n        attrs,\n        props,\n        scopedSlots: this.$scopedSlots,\n      }, this.$slots.default)\n    }\n  }\n}\n","import Vue from 'vue'\nimport * as components from './index'\n\nfor (const name in components) {\n  Vue.component(name, components[name])\n  Vue.component('Lazy' + name, components[name])\n}\n","/* eslint-disable no-console */\nimport Vuetify from '../framework'\n\nfunction createMessage (message: string, vm?: any, parent?: any): string | void {\n  if (Vuetify.config.silent) return\n\n  if (parent) {\n    vm = {\n      _isVue: true,\n      $parent: parent,\n      $options: vm,\n    }\n  }\n\n  if (vm) {\n    // Only show each message once per instance\n    vm.$_alreadyWarned = vm.$_alreadyWarned || []\n    if (vm.$_alreadyWarned.includes(message)) return\n    vm.$_alreadyWarned.push(message)\n  }\n\n  return `[Vuetify] ${message}` + (\n    vm ? generateComponentTrace(vm) : ''\n  )\n}\n\nexport function consoleInfo (message: string, vm?: any, parent?: any): void {\n  const newMessage = createMessage(message, vm, parent)\n  newMessage != null && console.info(newMessage)\n}\n\nexport function consoleWarn (message: string, vm?: any, parent?: any): void {\n  const newMessage = createMessage(message, vm, parent)\n  newMessage != null && console.warn(newMessage)\n}\n\nexport function consoleError (message: string, vm?: any, parent?: any): void {\n  const newMessage = createMessage(message, vm, parent)\n  newMessage != null && console.error(newMessage)\n}\n\nexport function deprecate (original: string, replacement: string, vm?: any, parent?: any) {\n  consoleWarn(`[UPGRADE] '${original}' is deprecated, use '${replacement}' instead.`, vm, parent)\n}\nexport function breaking (original: string, replacement: string, vm?: any, parent?: any) {\n  consoleError(`[BREAKING] '${original}' has been removed, use '${replacement}' instead. For more information, see the upgrade guide https://github.com/vuetifyjs/vuetify/releases/tag/v2.0.0#user-content-upgrade-guide`, vm, parent)\n}\nexport function removed (original: string, vm?: any, parent?: any) {\n  consoleWarn(`[REMOVED] '${original}' has been removed. You can safely omit it.`, vm, parent)\n}\n\n/**\n * Shamelessly stolen from vuejs/vue/blob/dev/src/core/util/debug.js\n */\n\nconst classifyRE = /(?:^|[-_])(\\w)/g\nconst classify = (str: string) => str\n  .replace(classifyRE, c => c.toUpperCase())\n  .replace(/[-_]/g, '')\n\nfunction formatComponentName (vm: any, includeFile?: boolean): string {\n  if (vm.$root === vm) {\n    return '<Root>'\n  }\n  const options = typeof vm === 'function' && vm.cid != null\n    ? vm.options\n    : vm._isVue\n      ? vm.$options || vm.constructor.options\n      : vm || {}\n  let name = options.name || options._componentTag\n  const file = options.__file\n  if (!name && file) {\n    const match = file.match(/([^/\\\\]+)\\.vue$/)\n    name = match && match[1]\n  }\n\n  return (\n    (name ? `<${classify(name)}>` : `<Anonymous>`) +\n    (file && includeFile !== false ? ` at ${file}` : '')\n  )\n}\n\nfunction generateComponentTrace (vm: any): string {\n  if (vm._isVue && vm.$parent) {\n    const tree: any[] = []\n    let currentRecursiveSequence = 0\n    while (vm) {\n      if (tree.length > 0) {\n        const last: any = tree[tree.length - 1]\n        if (last.constructor === vm.constructor) {\n          currentRecursiveSequence++\n          vm = vm.$parent\n          continue\n        } else if (currentRecursiveSequence > 0) {\n          tree[tree.length - 1] = [last, currentRecursiveSequence]\n          currentRecursiveSequence = 0\n        }\n      }\n      tree.push(vm)\n      vm = vm.$parent\n    }\n    return '\\n\\nfound in\\n\\n' + tree\n      .map((vm, i) => `${\n        i === 0 ? '---> ' : ' '.repeat(5 + i * 2)\n      }${\n        Array.isArray(vm)\n          ? `${formatComponentName(vm[0])}... (${vm[1]} recursive calls)`\n          : formatComponentName(vm)\n      }`)\n      .join('\\n')\n  } else {\n    return `\\n\\n(found in ${formatComponentName(vm)})`\n  }\n}\n","import OurVue, { VueConstructor } from 'vue'\nimport { VuetifyUseOptions } from 'vuetify/types'\nimport { consoleError } from './util/console'\n\nexport function install (Vue: VueConstructor, args: VuetifyUseOptions = {}) {\n  if ((install as any).installed) return\n  (install as any).installed = true\n\n  if (OurVue !== Vue) {\n    consoleError(`Multiple instances of Vue detected\nSee https://github.com/vuetifyjs/vuetify/issues/4068\n\nIf you're seeing \"$attrs is readonly\", it's caused by this`)\n  }\n\n  const components = args.components || {}\n  const directives = args.directives || {}\n\n  for (const name in directives) {\n    const directive = directives[name]\n\n    Vue.directive(name, directive)\n  }\n\n  (function registerComponents (components: any) {\n    if (components) {\n      for (const key in components) {\n        const component = components[key]\n        if (component && !registerComponents(component.$_vuetify_subcomponents)) {\n          Vue.component(key, component as typeof Vue)\n        }\n      }\n      return true\n    }\n    return false\n  })(components)\n\n  // Used to avoid multiple mixins being setup\n  // when in dev mode and hot module reload\n  // https://github.com/vuejs/vue/issues/5089#issuecomment-284260111\n  if (Vue.$_vuetify_installed) return\n  Vue.$_vuetify_installed = true\n\n  Vue.mixin({\n    beforeCreate () {\n      const options = this.$options as any\n\n      if (options.vuetify) {\n        options.vuetify.init(this, this.$ssrContext)\n        this.$vuetify = Vue.observable(options.vuetify.framework)\n      } else {\n        this.$vuetify = (options.parent && options.parent.$vuetify) || this\n      }\n    },\n    beforeMount () {\n      // @ts-ignore\n      if (this.$options.vuetify && this.$el && this.$el.hasAttribute('data-server-rendered')) {\n        // @ts-ignore\n        this.$vuetify.isHydrating = true\n        // @ts-ignore\n        this.$vuetify.breakpoint.update(true)\n      }\n    },\n    mounted () {\n      // @ts-ignore\n      if (this.$options.vuetify && this.$vuetify.isHydrating) {\n        // @ts-ignore\n        this.$vuetify.isHydrating = false\n        // @ts-ignore\n        this.$vuetify.breakpoint.update()\n      }\n    },\n  })\n}\n","export default {\n  badge: 'Badge',\n  close: 'Close',\n  dataIterator: {\n    noResultsText: 'No matching records found',\n    loadingText: 'Loading items...',\n  },\n  dataTable: {\n    itemsPerPageText: 'Rows per page:',\n    ariaLabel: {\n      sortDescending: 'Sorted descending.',\n      sortAscending: 'Sorted ascending.',\n      sortNone: 'Not sorted.',\n      activateNone: 'Activate to remove sorting.',\n      activateDescending: 'Activate to sort descending.',\n      activateAscending: 'Activate to sort ascending.',\n    },\n    sortBy: 'Sort by',\n  },\n  dataFooter: {\n    itemsPerPageText: 'Items per page:',\n    itemsPerPageAll: 'All',\n    nextPage: 'Next page',\n    prevPage: 'Previous page',\n    firstPage: 'First page',\n    lastPage: 'Last page',\n    pageText: '{0}-{1} of {2}',\n  },\n  datePicker: {\n    itemsSelected: '{0} selected',\n    nextMonthAriaLabel: 'Next month',\n    nextYearAriaLabel: 'Next year',\n    prevMonthAriaLabel: 'Previous month',\n    prevYearAriaLabel: 'Previous year',\n  },\n  noDataText: 'No data available',\n  carousel: {\n    prev: 'Previous visual',\n    next: 'Next visual',\n    ariaLabel: {\n      delimiter: 'Carousel slide {0} of {1}',\n    },\n  },\n  calendar: {\n    moreEvents: '{0} more',\n  },\n  fileInput: {\n    counter: '{0} files',\n    counterSize: '{0} files ({1} in total)',\n  },\n  timePicker: {\n    am: 'AM',\n    pm: 'PM',\n  },\n  pagination: {\n    ariaLabel: {\n      wrapper: 'Pagination Navigation',\n      next: 'Next page',\n      previous: 'Previous page',\n      page: 'Goto Page {0}',\n      currentPage: 'Current Page, Page {0}',\n    },\n  },\n  rating: {\n    ariaLabel: {\n      icon: 'Rating {0} of {1}',\n    },\n  },\n}\n","// Styles\nimport '../../styles/main.sass'\n\n// Locale\nimport { en } from '../../locale'\n\n// Icons\n// TODO: Enable for v3\n// import mdi from '../../services/icons/presets/mdi'\n\n// Types\nimport { VuetifyPreset } from 'vuetify/types/services/presets'\n\nexport const preset: VuetifyPreset = {\n  breakpoint: {\n    // TODO: update to MD2 spec in v3 - 1280\n    mobileBreakpoint: 1264,\n    scrollBarWidth: 16,\n    thresholds: {\n      xs: 600,\n      sm: 960,\n      md: 1280,\n      lg: 1920,\n    },\n  },\n  icons: {\n    // TODO: remove v3\n    iconfont: 'mdi',\n    values: {},\n  },\n  lang: {\n    current: 'en',\n    locales: { en },\n    // Default translator exists in lang service\n    t: undefined as any,\n  },\n  rtl: false,\n  theme: {\n    dark: false,\n    default: 'light',\n    disable: false,\n    options: {\n      cspNonce: undefined,\n      customProperties: undefined,\n      minifyTheme: undefined,\n      themeCache: undefined,\n      variations: true,\n    },\n    themes: {\n      light: {\n        primary: '#1976D2',\n        secondary: '#424242',\n        accent: '#82B1FF',\n        error: '#FF5252',\n        info: '#2196F3',\n        success: '#4CAF50',\n        warning: '#FB8C00',\n      },\n      dark: {\n        primary: '#2196F3',\n        secondary: '#424242',\n        accent: '#FF4081',\n        error: '#FF5252',\n        info: '#2196F3',\n        success: '#4CAF50',\n        warning: '#FB8C00',\n      },\n    },\n  },\n}\n","import Vue from 'vue'\nimport { VNode, VNodeDirective } from 'vue/types'\nimport { VuetifyIcon } from 'vuetify/types/services/icons'\nimport { DataTableCompareFunction, SelectItemKey, ItemGroup } from 'vuetify/types'\n\nexport function createSimpleFunctional (\n  c: string,\n  el = 'div',\n  name?: string\n) {\n  return Vue.extend({\n    name: name || c.replace(/__/g, '-'),\n\n    functional: true,\n\n    props: {\n      tag: {\n        type: String,\n        default: el,\n      },\n    },\n\n    render (h, { data, props, children }): VNode {\n      data.staticClass = (`${c} ${data.staticClass || ''}`).trim()\n\n      return h(props.tag, data, children)\n    },\n  })\n}\n\nexport type BindingConfig = Pick<VNodeDirective, 'arg' | 'modifiers' | 'value'>\nexport function directiveConfig (binding: BindingConfig, defaults = {}): VNodeDirective {\n  return {\n    ...defaults,\n    ...binding.modifiers,\n    value: binding.arg,\n    ...(binding.value || {}),\n  }\n}\n\nexport function addOnceEventListener (\n  el: EventTarget,\n  eventName: string,\n  cb: (event: Event) => void,\n  options: boolean | AddEventListenerOptions = false\n): void {\n  const once = (event: Event) => {\n    cb(event)\n    el.removeEventListener(eventName, once, options)\n  }\n\n  el.addEventListener(eventName, once, options)\n}\n\nlet passiveSupported = false\ntry {\n  if (typeof window !== 'undefined') {\n    const testListenerOpts = Object.defineProperty({}, 'passive', {\n      get: () => {\n        passiveSupported = true\n      },\n    }) as EventListener & EventListenerOptions\n\n    window.addEventListener('testListener', testListenerOpts, testListenerOpts)\n    window.removeEventListener('testListener', testListenerOpts, testListenerOpts)\n  }\n} catch (e) { console.warn(e) } /* eslint-disable-line no-console */\nexport { passiveSupported }\n\nexport function addPassiveEventListener (\n  el: EventTarget,\n  event: string,\n  cb: (event: any) => void,\n  options: {}\n): void {\n  el.addEventListener(event, cb, passiveSupported ? options : false)\n}\n\nexport function getNestedValue (obj: any, path: (string | number)[], fallback?: any): any {\n  const last = path.length - 1\n\n  if (last < 0) return obj === undefined ? fallback : obj\n\n  for (let i = 0; i < last; i++) {\n    if (obj == null) {\n      return fallback\n    }\n    obj = obj[path[i]]\n  }\n\n  if (obj == null) return fallback\n\n  return obj[path[last]] === undefined ? fallback : obj[path[last]]\n}\n\nexport function deepEqual (a: any, b: any): boolean {\n  if (a === b) return true\n\n  if (\n    a instanceof Date &&\n    b instanceof Date &&\n    a.getTime() !== b.getTime()\n  ) {\n    // If the values are Date, compare them as timestamps\n    return false\n  }\n\n  if (a !== Object(a) || b !== Object(b)) {\n    // If the values aren't objects, they were already checked for equality\n    return false\n  }\n\n  const props = Object.keys(a)\n\n  if (props.length !== Object.keys(b).length) {\n    // Different number of props, don't bother to check\n    return false\n  }\n\n  return props.every(p => deepEqual(a[p], b[p]))\n}\n\nexport function getObjectValueByPath (obj: any, path: string, fallback?: any): any {\n  // credit: http://stackoverflow.com/questions/6491463/accessing-nested-javascript-objects-with-string-key#comment55278413_6491621\n  if (obj == null || !path || typeof path !== 'string') return fallback\n  if (obj[path] !== undefined) return obj[path]\n  path = path.replace(/\\[(\\w+)\\]/g, '.$1') // convert indexes to properties\n  path = path.replace(/^\\./, '') // strip a leading dot\n  return getNestedValue(obj, path.split('.'), fallback)\n}\n\nexport function getPropertyFromItem (\n  item: object,\n  property: SelectItemKey,\n  fallback?: any\n): any {\n  if (property == null) return item === undefined ? fallback : item\n\n  if (item !== Object(item)) return fallback === undefined ? item : fallback\n\n  if (typeof property === 'string') return getObjectValueByPath(item, property, fallback)\n\n  if (Array.isArray(property)) return getNestedValue(item, property, fallback)\n\n  if (typeof property !== 'function') return fallback\n\n  const value = property(item, fallback)\n\n  return typeof value === 'undefined' ? fallback : value\n}\n\nexport function createRange (length: number): number[] {\n  return Array.from({ length }, (v, k) => k)\n}\n\nexport function getZIndex (el?: Element | null): number {\n  if (!el || el.nodeType !== Node.ELEMENT_NODE) return 0\n\n  const index = +window.getComputedStyle(el).getPropertyValue('z-index')\n\n  if (!index) return getZIndex(el.parentNode as Element)\n  return index\n}\n\nexport function filterObjectOnKeys<T, K extends keyof T> (obj: T, keys: K[]): { [N in K]: T[N] } {\n  const filtered = {} as { [N in K]: T[N] }\n\n  for (let i = 0; i < keys.length; i++) {\n    const key = keys[i]\n    if (typeof obj[key] !== 'undefined') {\n      filtered[key] = obj[key]\n    }\n  }\n\n  return filtered\n}\n\nexport function convertToUnit (str: string | number | null | undefined, unit = 'px'): string | undefined {\n  if (str == null || str === '') {\n    return undefined\n  } else if (isNaN(+str!)) {\n    return String(str)\n  } else {\n    return `${Number(str)}${unit}`\n  }\n}\n\nexport function kebabCase (str: string): string {\n  return (str || '').replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase()\n}\n\nexport function isObject (obj: any): obj is object {\n  return obj !== null && typeof obj === 'object'\n}\n\n// KeyboardEvent.keyCode aliases\nexport const keyCodes = Object.freeze({\n  enter: 13,\n  tab: 9,\n  delete: 46,\n  esc: 27,\n  space: 32,\n  up: 38,\n  down: 40,\n  left: 37,\n  right: 39,\n  end: 35,\n  home: 36,\n  del: 46,\n  backspace: 8,\n  insert: 45,\n  pageup: 33,\n  pagedown: 34,\n  shift: 16,\n})\n\n/**\n * This remaps internal names like '$cancel' or '$vuetify.icons.cancel'\n * to the current name or component for that icon.\n */\nexport function remapInternalIcon (vm: Vue, iconName: string): VuetifyIcon {\n  // Look for custom component in the configuration\n  const component = vm.$vuetify.icons.component\n\n  // Look for overrides\n  if (iconName.startsWith('$')) {\n    // Get the target icon name\n    const iconPath = `$vuetify.icons.values.${iconName.split('$').pop()!.split('.').pop()}`\n\n    // Now look up icon indirection name,\n    // e.g. '$vuetify.icons.values.cancel'\n    const override = getObjectValueByPath(vm, iconPath, iconName)\n\n    if (typeof override === 'string') iconName = override\n    else return override\n  }\n\n  if (component == null) {\n    return iconName\n  }\n\n  return {\n    component,\n    props: {\n      icon: iconName,\n    },\n  }\n}\n\nexport function keys<O> (o: O) {\n  return Object.keys(o) as (keyof O)[]\n}\n\n/**\n * Camelize a hyphen-delimited string.\n */\nconst camelizeRE = /-(\\w)/g\nexport const camelize = (str: string): string => {\n  return str.replace(camelizeRE, (_, c) => c ? c.toUpperCase() : '')\n}\n\n/**\n * Returns the set difference of B and A, i.e. the set of elements in B but not in A\n */\nexport function arrayDiff (a: any[], b: any[]): any[] {\n  const diff: any[] = []\n  for (let i = 0; i < b.length; i++) {\n    if (a.indexOf(b[i]) < 0) diff.push(b[i])\n  }\n  return diff\n}\n\n/**\n * Makes the first character of a string uppercase\n */\nexport function upperFirst (str: string): string {\n  return str.charAt(0).toUpperCase() + str.slice(1)\n}\n\nexport function groupItems<T extends any = any> (\n  items: T[],\n  groupBy: string[],\n  groupDesc: boolean[]\n): ItemGroup<T>[] {\n  const key = groupBy[0]\n  const groups: ItemGroup<T>[] = []\n  let current\n  for (let i = 0; i < items.length; i++) {\n    const item = items[i]\n    const val = getObjectValueByPath(item, key, null)\n    if (current !== val) {\n      current = val\n      groups.push({\n        name: val ?? '',\n        items: [],\n      })\n    }\n    groups[groups.length - 1].items.push(item)\n  }\n  return groups\n}\n\nexport function wrapInArray<T> (v: T | T[] | null | undefined): T[] { return v != null ? Array.isArray(v) ? v : [v] : [] }\n\nexport function sortItems<T extends any = any> (\n  items: T[],\n  sortBy: string[],\n  sortDesc: boolean[],\n  locale: string,\n  customSorters?: Record<string, DataTableCompareFunction<T>>\n): T[] {\n  if (sortBy === null || !sortBy.length) return items\n  const stringCollator = new Intl.Collator(locale, { sensitivity: 'accent', usage: 'sort' })\n\n  return items.sort((a, b) => {\n    for (let i = 0; i < sortBy.length; i++) {\n      const sortKey = sortBy[i]\n\n      let sortA = getObjectValueByPath(a, sortKey)\n      let sortB = getObjectValueByPath(b, sortKey)\n\n      if (sortDesc[i]) {\n        [sortA, sortB] = [sortB, sortA]\n      }\n\n      if (customSorters && customSorters[sortKey]) {\n        const customResult = customSorters[sortKey](sortA, sortB)\n\n        if (!customResult) continue\n\n        return customResult\n      }\n\n      // Check if both cannot be evaluated\n      if (sortA === null && sortB === null) {\n        continue\n      }\n\n      // Dates should be compared numerically\n      if (sortA instanceof Date && sortB instanceof Date) {\n        return sortA.getTime() - sortB.getTime()\n      }\n\n      [sortA, sortB] = [sortA, sortB].map(s => (s || '').toString().toLocaleLowerCase())\n\n      if (sortA !== sortB) {\n        if (!isNaN(sortA) && !isNaN(sortB)) return Number(sortA) - Number(sortB)\n        return stringCollator.compare(sortA, sortB)\n      }\n    }\n\n    return 0\n  })\n}\n\nexport function defaultFilter (value: any, search: string | null, item: any) {\n  return value != null &&\n    search != null &&\n    typeof value !== 'boolean' &&\n    value.toString().toLocaleLowerCase().indexOf(search.toLocaleLowerCase()) !== -1\n}\n\nexport function searchItems<T extends any = any> (items: T[], search: string): T[] {\n  if (!search) return items\n  search = search.toString().toLowerCase()\n  if (search.trim() === '') return items\n\n  return items.filter((item: any) => Object.keys(item).some(key => defaultFilter(getObjectValueByPath(item, key), search, item)))\n}\n\n/**\n * Returns:\n *  - 'normal' for old style slots - `<template slot=\"default\">`\n *  - 'scoped' for old style scoped slots (`<template slot=\"default\" slot-scope=\"data\">`) or bound v-slot (`#default=\"data\"`)\n *  - 'v-slot' for unbound v-slot (`#default`) - only if the third param is true, otherwise counts as scoped\n */\nexport function getSlotType<T extends boolean = false> (vm: Vue, name: string, split?: T): (T extends true ? 'v-slot' : never) | 'normal' | 'scoped' | void {\n  if (vm.$slots.hasOwnProperty(name) && vm.$scopedSlots.hasOwnProperty(name) && (vm.$scopedSlots[name] as any).name) {\n    return split ? 'v-slot' as any : 'scoped'\n  }\n  if (vm.$slots.hasOwnProperty(name)) return 'normal'\n  if (vm.$scopedSlots.hasOwnProperty(name)) return 'scoped'\n}\n\nexport function debounce (fn: Function, delay: number) {\n  let timeoutId = 0 as any\n  return (...args: any[]) => {\n    clearTimeout(timeoutId)\n    timeoutId = setTimeout(() => fn(...args), delay)\n  }\n}\n\nexport function throttle<T extends (...args: any[]) => any> (fn: T, limit: number) {\n  let throttling = false\n  return (...args: Parameters<T>): void | ReturnType<T> => {\n    if (!throttling) {\n      throttling = true\n      setTimeout(() => throttling = false, limit)\n      return fn(...args)\n    }\n  }\n}\n\nexport function getPrefixedScopedSlots (prefix: string, scopedSlots: any) {\n  return Object.keys(scopedSlots).filter(k => k.startsWith(prefix)).reduce((obj: any, k: string) => {\n    obj[k.replace(prefix, '')] = scopedSlots[k]\n    return obj\n  }, {})\n}\n\nexport function getSlot (vm: Vue, name = 'default', data?: object | (() => object), optional = false) {\n  if (vm.$scopedSlots.hasOwnProperty(name)) {\n    return vm.$scopedSlots[name]!(data instanceof Function ? data() : data)\n  } else if (vm.$slots.hasOwnProperty(name) && (!data || optional)) {\n    return vm.$slots[name]\n  }\n  return undefined\n}\n\nexport function clamp (value: number, min = 0, max = 1) {\n  return Math.max(min, Math.min(max, value))\n}\n\nexport function padEnd (str: string, length: number, char = '0') {\n  return str + char.repeat(Math.max(0, length - str.length))\n}\n\nexport function chunk (str: string, size = 1) {\n  const chunked: string[] = []\n  let index = 0\n  while (index < str.length) {\n    chunked.push(str.substr(index, size))\n    index += size\n  }\n  return chunked\n}\n\nexport function humanReadableFileSize (bytes: number, binary = false): string {\n  const base = binary ? 1024 : 1000\n  if (bytes < base) {\n    return `${bytes} B`\n  }\n\n  const prefix = binary ? ['Ki', 'Mi', 'Gi'] : ['k', 'M', 'G']\n  let unit = -1\n  while (Math.abs(bytes) >= base && unit < prefix.length - 1) {\n    bytes /= base\n    ++unit\n  }\n  return `${bytes.toFixed(1)} ${prefix[unit]}B`\n}\n\nexport function camelizeObjectKeys (obj: Record<string, any> | null | undefined) {\n  if (!obj) return {}\n\n  return Object.keys(obj).reduce((o: any, key: string) => {\n    o[camelize(key)] = obj[key]\n    return o\n  }, {})\n}\n\nexport function mergeDeep (\n  source: Dictionary<any> = {},\n  target: Dictionary<any> = {}\n) {\n  for (const key in target) {\n    const sourceProperty = source[key]\n    const targetProperty = target[key]\n\n    // Only continue deep merging if\n    // both properties are objects\n    if (\n      isObject(sourceProperty) &&\n      isObject(targetProperty)\n    ) {\n      source[key] = mergeDeep(sourceProperty, targetProperty)\n\n      continue\n    }\n\n    source[key] = targetProperty\n  }\n\n  return source\n}\n\nexport function fillArray<T> (length: number, obj: T) {\n  return Array(length).fill(obj)\n}\n\n/**  Polyfill for Event.prototype.composedPath */\nexport function composedPath (e: Event): EventTarget[] {\n  if (e.composedPath) return e.composedPath()\n\n  const path = []\n  let el = e.target as Element\n\n  while (el) {\n    path.push(el)\n\n    if (el.tagName === 'HTML') {\n      path.push(document)\n      path.push(window)\n\n      return path\n    }\n\n    el = el.parentElement!\n  }\n  return path\n}\n","// Contracts\nimport { VuetifyServiceContract } from 'vuetify/types/services/index'\n\n// Types\nimport Vue from 'vue'\n\nexport class Service implements VuetifyServiceContract {\n  framework = {}\n\n  init (root: Vue, ssrContext?: object) {}\n}\n","// Preset\nimport { preset as Preset } from '../../presets/default'\n\n// Utilities\nimport { consoleWarn } from '../../util/console'\nimport { mergeDeep } from '../../util/helpers'\n\n// Types\nimport Vuetify from 'vuetify/types'\nimport { Service } from '../service'\nimport {\n  UserVuetifyPreset,\n  VuetifyPreset,\n} from 'vuetify/types/services/presets'\n\nexport class Presets extends Service {\n  static property: 'presets' = 'presets'\n\n  constructor (\n    parentPreset: Partial<UserVuetifyPreset>,\n    parent: Vuetify,\n  ) {\n    super()\n\n    // The default preset\n    const defaultPreset = mergeDeep({}, Preset)\n    // The user provided preset\n    const { userPreset } = parent\n    // The user provided global preset\n    const {\n      preset: globalPreset = {},\n      ...preset\n    } = userPreset\n\n    if (globalPreset.preset != null) {\n      consoleWarn('Global presets do not support the **preset** option, it can be safely omitted')\n    }\n\n    parent.preset = mergeDeep(\n      mergeDeep(defaultPreset, globalPreset),\n      preset\n    ) as VuetifyPreset\n  }\n}\n","// Extensions\nimport { Service } from '../service'\n\n// Types\nimport { TargetPropValues, TargetProp, Application as IApplication } from 'vuetify/types/services/application'\n\nexport class Application extends Service implements IApplication {\n  static property: 'application' = 'application'\n\n  bar = 0\n\n  top = 0\n\n  left = 0\n\n  insetFooter = 0\n\n  right = 0\n\n  bottom = 0\n\n  footer = 0\n\n  application: Dictionary<TargetPropValues> = {\n    bar: {},\n    top: {},\n    left: {},\n    insetFooter: {},\n    right: {},\n    bottom: {},\n    footer: {},\n  }\n\n  register (\n    uid: number,\n    location: TargetProp,\n    size: number\n  ) {\n    this.application[location][uid] = size\n\n    this.update(location)\n  }\n\n  unregister (uid: number, location: TargetProp) {\n    if (this.application[location][uid] == null) return\n\n    delete this.application[location][uid]\n    this.update(location)\n  }\n\n  update (location: TargetProp) {\n    this[location] = Object.values(this.application[location])\n      .reduce((acc: number, cur: number): number => (acc + cur), 0)\n  }\n}\n","// Extensions\nimport { Service } from '../service'\n\n// Types\nimport { VuetifyPreset } from 'vuetify/types/services/presets'\nimport { Breakpoint as IBreakpoint } from 'vuetify/types/services/breakpoint'\n\nexport class Breakpoint extends Service implements IBreakpoint {\n  public static property: 'breakpoint' = 'breakpoint'\n\n  // Public\n  public xs = false\n\n  public sm = false\n\n  public md = false\n\n  public lg = false\n\n  public xl = false\n\n  public xsOnly = false\n\n  public smOnly = false\n\n  public smAndDown = false\n\n  public smAndUp = false\n\n  public mdOnly = false\n\n  public mdAndDown = false\n\n  public mdAndUp = false\n\n  public lgOnly = false\n\n  public lgAndDown = false\n\n  public lgAndUp = false\n\n  public xlOnly = false\n\n  // Value is xs to match v2.x functionality\n  public name: IBreakpoint['name'] = 'xs'\n\n  public height = 0\n\n  public width = 0\n\n  // TODO: Add functionality to detect this dynamically in v3\n  // Value is true to match v2.x functionality\n  public mobile = true\n\n  public mobileBreakpoint: IBreakpoint['mobileBreakpoint']\n\n  public thresholds: IBreakpoint['thresholds']\n\n  public scrollBarWidth: IBreakpoint['scrollBarWidth']\n\n  private resizeTimeout = 0\n\n  constructor (preset: VuetifyPreset) {\n    super()\n\n    const {\n      mobileBreakpoint,\n      scrollBarWidth,\n      thresholds,\n    } = preset[Breakpoint.property]\n\n    this.mobileBreakpoint = mobileBreakpoint\n    this.scrollBarWidth = scrollBarWidth\n    this.thresholds = thresholds\n  }\n\n  public init () {\n    this.update()\n\n    /* istanbul ignore if */\n    if (typeof window === 'undefined') return\n\n    window.addEventListener(\n      'resize',\n      this.onResize.bind(this),\n      { passive: true }\n    )\n  }\n\n  /* eslint-disable-next-line max-statements */\n  public update (ssr = false) {\n    const height = ssr ? 0 : this.getClientHeight()\n    const width = ssr ? 0 : this.getClientWidth()\n\n    const xs = width < this.thresholds.xs\n    const sm = width < this.thresholds.sm && !xs\n    const md = width < (this.thresholds.md - this.scrollBarWidth) && !(sm || xs)\n    const lg = width < (this.thresholds.lg - this.scrollBarWidth) && !(md || sm || xs)\n    const xl = width >= (this.thresholds.lg - this.scrollBarWidth)\n\n    this.height = height\n    this.width = width\n\n    this.xs = xs\n    this.sm = sm\n    this.md = md\n    this.lg = lg\n    this.xl = xl\n\n    this.xsOnly = xs\n    this.smOnly = sm\n    this.smAndDown = (xs || sm) && !(md || lg || xl)\n    this.smAndUp = !xs && (sm || md || lg || xl)\n    this.mdOnly = md\n    this.mdAndDown = (xs || sm || md) && !(lg || xl)\n    this.mdAndUp = !(xs || sm) && (md || lg || xl)\n    this.lgOnly = lg\n    this.lgAndDown = (xs || sm || md || lg) && !xl\n    this.lgAndUp = !(xs || sm || md) && (lg || xl)\n    this.xlOnly = xl\n\n    switch (true) {\n      case (xs):\n        this.name = 'xs'\n        break\n      case (sm):\n        this.name = 'sm'\n        break\n      case (md):\n        this.name = 'md'\n        break\n      case (lg):\n        this.name = 'lg'\n        break\n      default:\n        this.name = 'xl'\n        break\n    }\n\n    if (typeof this.mobileBreakpoint === 'number') {\n      this.mobile = width < parseInt(this.mobileBreakpoint, 10)\n\n      return\n    }\n\n    const breakpoints = {\n      xs: 0,\n      sm: 1,\n      md: 2,\n      lg: 3,\n      xl: 4,\n    } as const\n\n    const current = breakpoints[this.name]\n    const max = breakpoints[this.mobileBreakpoint]\n\n    this.mobile = current <= max\n  }\n\n  private onResize () {\n    clearTimeout(this.resizeTimeout)\n\n    // Added debounce to match what\n    // v-resize used to do but was\n    // removed due to a memory leak\n    // https://github.com/vuetifyjs/vuetify/pull/2997\n    this.resizeTimeout = window.setTimeout(this.update.bind(this), 200)\n  }\n\n  // Cross-browser support as described in:\n  // https://stackoverflow.com/questions/1248081\n  private getClientWidth () {\n    /* istanbul ignore if */\n    if (typeof document === 'undefined') return 0 // SSR\n    return Math.max(\n      document.documentElement!.clientWidth,\n      window.innerWidth || 0\n    )\n  }\n\n  private getClientHeight () {\n    /* istanbul ignore if */\n    if (typeof document === 'undefined') return 0 // SSR\n    return Math.max(\n      document.documentElement!.clientHeight,\n      window.innerHeight || 0\n    )\n  }\n}\n","export type EasingFunction = (t: number) => number\n\n// linear\nexport const linear = (t: number) => t\n// accelerating from zero velocity\nexport const easeInQuad = (t: number) => t ** 2\n// decelerating to zero velocity\nexport const easeOutQuad = (t: number) => t * (2 - t)\n// acceleration until halfway, then deceleration\nexport const easeInOutQuad = (t: number) => (t < 0.5 ? 2 * t ** 2 : -1 + (4 - 2 * t) * t)\n// accelerating from zero velocity\nexport const easeInCubic = (t: number) => t ** 3\n// decelerating to zero velocity\nexport const easeOutCubic = (t: number) => --t ** 3 + 1\n// acceleration until halfway, then deceleration\nexport const easeInOutCubic = (t: number) => t < 0.5 ? 4 * t ** 3 : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1\n// accelerating from zero velocity\nexport const easeInQuart = (t: number) => t ** 4\n// decelerating to zero velocity\nexport const easeOutQuart = (t: number) => 1 - --t ** 4\n// acceleration until halfway, then deceleration\nexport const easeInOutQuart = (t: number) => (t < 0.5 ? 8 * t * t * t * t : 1 - 8 * --t * t * t * t)\n// accelerating from zero velocity\nexport const easeInQuint = (t: number) => t ** 5\n// decelerating to zero velocity\nexport const easeOutQuint = (t: number) => 1 + --t ** 5\n// acceleration until halfway, then deceleration\nexport const easeInOutQuint = (t: number) => t < 0.5 ? 16 * t ** 5 : 1 + 16 * --t ** 5\n","import Vue from 'vue'\n\n// Return target's cumulative offset from the top\nexport function getOffset (target: any): number {\n  if (typeof target === 'number') {\n    return target\n  }\n\n  let el = $(target)\n  if (!el) {\n    throw typeof target === 'string'\n      ? new Error(`Target element \"${target}\" not found.`)\n      : new TypeError(`Target must be a Number/Selector/HTMLElement/VueComponent, received ${type(target)} instead.`)\n  }\n\n  let totalOffset = 0\n  while (el) {\n    totalOffset += el.offsetTop\n    el = el.offsetParent as HTMLElement\n  }\n\n  return totalOffset\n}\n\nexport function getContainer (container: any): HTMLElement {\n  const el = $(container)\n\n  if (el) return el\n\n  throw typeof container === 'string'\n    ? new Error(`Container element \"${container}\" not found.`)\n    : new TypeError(`Container must be a Selector/HTMLElement/VueComponent, received ${type(container)} instead.`)\n}\n\nfunction type (el: any) {\n  return el == null ? el : el.constructor.name\n}\n\nfunction $ (el: any): HTMLElement | null {\n  if (typeof el === 'string') {\n    return document.querySelector<HTMLElement>(el)\n  } else if (el && el._isVue) {\n    return (el as Vue).$el as HTMLElement\n  } else if (el instanceof HTMLElement) {\n    return el\n  } else {\n    return null\n  }\n}\n","// Extensions\nimport { Service } from '../service'\n\n// Utilities\nimport * as easingPatterns from './easing-patterns'\nimport {\n  getContainer,\n  getOffset,\n} from './util'\n\n// Types\nimport { GoToOptions, VuetifyGoToTarget } from 'vuetify/types/services/goto'\n\nimport { VuetifyServiceContract } from 'vuetify/types/services'\n\nexport default function goTo (\n  _target: VuetifyGoToTarget,\n  _settings: GoToOptions = {}\n): Promise<number> {\n  const settings: GoToOptions = {\n    container: (document.scrollingElement as HTMLElement | null) || document.body || document.documentElement,\n    duration: 500,\n    offset: 0,\n    easing: 'easeInOutCubic',\n    appOffset: true,\n    ..._settings,\n  }\n  const container = getContainer(settings.container)\n\n  /* istanbul ignore else */\n  if (settings.appOffset && goTo.framework.application) {\n    const isDrawer = container.classList.contains('v-navigation-drawer')\n    const isClipped = container.classList.contains('v-navigation-drawer--clipped')\n    const { bar, top } = goTo.framework.application as any\n\n    settings.offset += bar\n    /* istanbul ignore else */\n    if (!isDrawer || isClipped) settings.offset += top\n  }\n\n  const startTime = performance.now()\n\n  let targetLocation: number\n  if (typeof _target === 'number') {\n    targetLocation = getOffset(_target) - settings.offset!\n  } else {\n    targetLocation = getOffset(_target) - getOffset(container) - settings.offset!\n  }\n\n  const startLocation = container.scrollTop\n  if (targetLocation === startLocation) return Promise.resolve(targetLocation)\n\n  const ease = typeof settings.easing === 'function'\n    ? settings.easing\n    : easingPatterns[settings.easing!]\n  /* istanbul ignore else */\n  if (!ease) throw new TypeError(`Easing function \"${settings.easing}\" not found.`)\n\n  // Cannot be tested properly in jsdom\n  /* istanbul ignore next */\n  return new Promise(resolve => requestAnimationFrame(function step (currentTime: number) {\n    const timeElapsed = currentTime - startTime\n    const progress = Math.abs(settings.duration ? Math.min(timeElapsed / settings.duration, 1) : 1)\n\n    container.scrollTop = Math.floor(startLocation + (targetLocation - startLocation) * ease(progress))\n\n    const clientHeight = container === document.body ? document.documentElement.clientHeight : container.clientHeight\n    const reachBottom = clientHeight + container.scrollTop >= container.scrollHeight\n    if (\n      progress === 1 ||\n      // Need to go lower but reach bottom\n      (targetLocation > container.scrollTop && reachBottom)\n    ) {\n      return resolve(targetLocation)\n    }\n\n    requestAnimationFrame(step)\n  }))\n}\n\ngoTo.framework = {} as Record<string, VuetifyServiceContract>\ngoTo.init = () => {}\n\nexport class Goto extends Service {\n  public static property: 'goTo' = 'goTo'\n\n  constructor () {\n    super()\n\n    return goTo\n  }\n}\n","import { VuetifyIcons } from 'vuetify/types/services/icons'\n\nconst icons: VuetifyIcons = {\n  complete: 'M21,7L9,19L3.5,13.5L4.91,12.09L9,16.17L19.59,5.59L21,7Z',\n  cancel: 'M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z',\n  close: 'M19,6.41L17.59,5L12,10.59L6.41,5L5,6.41L10.59,12L5,17.59L6.41,19L12,13.41L17.59,19L19,17.59L13.41,12L19,6.41Z',\n  delete: 'M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z', // delete (e.g. v-chip close)\n  clear: 'M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z',\n  success: 'M12 2C6.5 2 2 6.5 2 12S6.5 22 12 22 22 17.5 22 12 17.5 2 12 2M10 17L5 12L6.41 10.59L10 14.17L17.59 6.58L19 8L10 17Z',\n  info: 'M13,9H11V7H13M13,17H11V11H13M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2ZM13,9H11V7H13M13,17H11V11H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z',\n  warning: 'M13,13H11V7H13M13,17H11V15H13M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2Z',\n  error: 'M12,2C17.53,2 22,6.47 22,12C22,17.53 17.53,22 12,22C6.47,22 2,17.53 2,12C2,6.47 6.47,2 12,2M15.59,7L12,10.59L8.41,7L7,8.41L10.59,12L7,15.59L8.41,17L12,13.41L15.59,17L17,15.59L13.41,12L17,8.41L15.59,7Z',\n  prev: 'M15.41,16.58L10.83,12L15.41,7.41L14,6L8,12L14,18L15.41,16.58Z',\n  next: 'M8.59,16.58L13.17,12L8.59,7.41L10,6L16,12L10,18L8.59,16.58Z',\n  checkboxOn: 'M10,17L5,12L6.41,10.58L10,14.17L17.59,6.58L19,8M19,3H5C3.89,3 3,3.89 3,5V19C3,20.1 3.9,21 5,21H19C20.1,21 21,20.1 21,19V5C21,3.89 20.1,3 19,3Z',\n  checkboxOff: 'M19,3H5C3.89,3 3,3.89 3,5V19C3,20.1 3.9,21 5,21H19C20.1,21 21,20.1 21,19V5C21,3.89 20.1,3 19,3M19,5V19H5V5H19Z',\n  checkboxIndeterminate: 'M17,13H7V11H17M19,3H5C3.89,3 3,3.89 3,5V19C3,20.1 3.9,21 5,21H19C20.1,21 21,20.1 21,19V5C21,3.89 20.1,3 19,3Z',\n  delimiter: 'M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2Z', // for carousel\n  sort: 'M13,20H11V8L5.5,13.5L4.08,12.08L12,4.16L19.92,12.08L18.5,13.5L13,8V20Z',\n  expand: 'M7.41,8.58L12,13.17L16.59,8.58L18,10L12,16L6,10L7.41,8.58Z',\n  menu: 'M3,6H21V8H3V6M3,11H21V13H3V11M3,16H21V18H3V16Z',\n  subgroup: 'M7,10L12,15L17,10H7Z',\n  dropdown: 'M7,10L12,15L17,10H7Z',\n  radioOn: 'M12,20C7.58,20 4,16.42 4,12C4,7.58 7.58,4 12,4C16.42,4 20,7.58 20,12C20,16.42 16.42,20 12,20M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2M12,7C9.24,7 7,9.24 7,12C7,14.76 9.24,17 12,17C14.76,17 17,14.76 17,12C17,9.24 14.76,7 12,7Z',\n  radioOff: 'M12,20C7.58,20 4,16.42 4,12C4,7.58 7.58,4 12,4C16.42,4 20,7.58 20,12C20,16.42 16.42,20 12,20M12,2C6.48,2 2,6.48 2,12C2,17.52 6.48,22 12,22C17.52,22 22,17.52 22,12C22,6.48 17.52,2 12,2Z',\n  edit: 'M20.71,7.04C21.1,6.65 21.1,6 20.71,5.63L18.37,3.29C18,2.9 17.35,2.9 16.96,3.29L15.12,5.12L18.87,8.87M3,17.25V21H6.75L17.81,9.93L14.06,6.18L3,17.25Z',\n  ratingEmpty: 'M12,15.39L8.24,17.66L9.23,13.38L5.91,10.5L10.29,10.13L12,6.09L13.71,10.13L18.09,10.5L14.77,13.38L15.76,17.66M22,9.24L14.81,8.63L12,2L9.19,8.63L2,9.24L7.45,13.97L5.82,21L12,17.27L18.18,21L16.54,13.97L22,9.24Z',\n  ratingFull: 'M12,17.27L18.18,21L16.54,13.97L22,9.24L14.81,8.62L12,2L9.19,8.62L2,9.24L7.45,13.97L5.82,21L12,17.27Z',\n  ratingHalf: 'M12,15.4V6.1L13.71,10.13L18.09,10.5L14.77,13.39L15.76,17.67M22,9.24L14.81,8.63L12,2L9.19,8.63L2,9.24L7.45,13.97L5.82,21L12,17.27L18.18,21L16.54,13.97L22,9.24Z',\n  loading: 'M19,8L15,12H18C18,15.31 15.31,18 12,18C11,18 10.03,17.75 9.2,17.3L7.74,18.76C8.97,19.54 10.43,20 12,20C16.42,20 20,16.42 20,12H23M6,12C6,8.69 8.69,6 12,6C13,6 13.97,6.25 14.8,6.7L16.26,5.24C15.03,4.46 13.57,4 12,4C7.58,4 4,7.58 4,12H1L5,16L9,12',\n  first: 'M18.41,16.59L13.82,12L18.41,7.41L17,6L11,12L17,18L18.41,16.59M6,6H8V18H6V6Z',\n  last: 'M5.59,7.41L10.18,12L5.59,16.59L7,18L13,12L7,6L5.59,7.41M16,6H18V18H16V6Z',\n  unfold: 'M12,18.17L8.83,15L7.42,16.41L12,21L16.59,16.41L15.17,15M12,5.83L15.17,9L16.58,7.59L12,3L7.41,7.59L8.83,9L12,5.83Z',\n  file: 'M16.5,6V17.5C16.5,19.71 14.71,21.5 12.5,21.5C10.29,21.5 8.5,19.71 8.5,17.5V5C8.5,3.62 9.62,2.5 11,2.5C12.38,2.5 13.5,3.62 13.5,5V15.5C13.5,16.05 13.05,16.5 12.5,16.5C11.95,16.5 11.5,16.05 11.5,15.5V6H10V15.5C10,16.88 11.12,18 12.5,18C13.88,18 15,16.88 15,15.5V5C15,2.79 13.21,1 11,1C8.79,1 7,2.79 7,5V17.5C7,20.54 9.46,23 12.5,23C15.54,23 18,20.54 18,17.5V6H16.5Z',\n  plus: 'M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z',\n  minus: 'M19,13H5V11H19V13Z',\n}\n\nexport default icons\n","import { VuetifyIcons } from 'vuetify/types/services/icons'\n\nconst icons: VuetifyIcons = {\n  complete: 'check',\n  cancel: 'cancel',\n  close: 'close',\n  delete: 'cancel', // delete (e.g. v-chip close)\n  clear: 'clear',\n  success: 'check_circle',\n  info: 'info',\n  warning: 'priority_high',\n  error: 'warning',\n  prev: 'chevron_left',\n  next: 'chevron_right',\n  checkboxOn: 'check_box',\n  checkboxOff: 'check_box_outline_blank',\n  checkboxIndeterminate: 'indeterminate_check_box',\n  delimiter: 'fiber_manual_record', // for carousel\n  sort: 'arrow_upward',\n  expand: 'keyboard_arrow_down',\n  menu: 'menu',\n  subgroup: 'arrow_drop_down',\n  dropdown: 'arrow_drop_down',\n  radioOn: 'radio_button_checked',\n  radioOff: 'radio_button_unchecked',\n  edit: 'edit',\n  ratingEmpty: 'star_border',\n  ratingFull: 'star',\n  ratingHalf: 'star_half',\n  loading: 'cached',\n  first: 'first_page',\n  last: 'last_page',\n  unfold: 'unfold_more',\n  file: 'attach_file',\n  plus: 'add',\n  minus: 'remove',\n}\n\nexport default icons\n","import { VuetifyIcons } from 'vuetify/types/services/icons'\n\nconst icons: VuetifyIcons = {\n  complete: 'mdi-check',\n  cancel: 'mdi-close-circle',\n  close: 'mdi-close',\n  delete: 'mdi-close-circle', // delete (e.g. v-chip close)\n  clear: 'mdi-close',\n  success: 'mdi-check-circle',\n  info: 'mdi-information',\n  warning: 'mdi-exclamation',\n  error: 'mdi-alert',\n  prev: 'mdi-chevron-left',\n  next: 'mdi-chevron-right',\n  checkboxOn: 'mdi-checkbox-marked',\n  checkboxOff: 'mdi-checkbox-blank-outline',\n  checkboxIndeterminate: 'mdi-minus-box',\n  delimiter: 'mdi-circle', // for carousel\n  sort: 'mdi-arrow-up',\n  expand: 'mdi-chevron-down',\n  menu: 'mdi-menu',\n  subgroup: 'mdi-menu-down',\n  dropdown: 'mdi-menu-down',\n  radioOn: 'mdi-radiobox-marked',\n  radioOff: 'mdi-radiobox-blank',\n  edit: 'mdi-pencil',\n  ratingEmpty: 'mdi-star-outline',\n  ratingFull: 'mdi-star',\n  ratingHalf: 'mdi-star-half-full',\n  loading: 'mdi-cached',\n  first: 'mdi-page-first',\n  last: 'mdi-page-last',\n  unfold: 'mdi-unfold-more-horizontal',\n  file: 'mdi-paperclip',\n  plus: 'mdi-plus',\n  minus: 'mdi-minus',\n}\n\nexport default icons\n","import { VuetifyIcons } from 'vuetify/types/services/icons'\n\nconst icons: VuetifyIcons = {\n  complete: 'fas fa-check',\n  cancel: 'fas fa-times-circle',\n  close: 'fas fa-times',\n  delete: 'fas fa-times-circle', // delete (e.g. v-chip close)\n  clear: 'fas fa-times-circle', // delete (e.g. v-chip close)\n  success: 'fas fa-check-circle',\n  info: 'fas fa-info-circle',\n  warning: 'fas fa-exclamation',\n  error: 'fas fa-exclamation-triangle',\n  prev: 'fas fa-chevron-left',\n  next: 'fas fa-chevron-right',\n  checkboxOn: 'fas fa-check-square',\n  checkboxOff: 'far fa-square', // note 'far'\n  checkboxIndeterminate: 'fas fa-minus-square',\n  delimiter: 'fas fa-circle', // for carousel\n  sort: 'fas fa-sort-up',\n  expand: 'fas fa-chevron-down',\n  menu: 'fas fa-bars',\n  subgroup: 'fas fa-caret-down',\n  dropdown: 'fas fa-caret-down',\n  radioOn: 'far fa-dot-circle',\n  radioOff: 'far fa-circle',\n  edit: 'fas fa-edit',\n  ratingEmpty: 'far fa-star',\n  ratingFull: 'fas fa-star',\n  ratingHalf: 'fas fa-star-half',\n  loading: 'fas fa-sync',\n  first: 'fas fa-step-backward',\n  last: 'fas fa-step-forward',\n  unfold: 'fas fa-arrows-alt-v',\n  file: 'fas fa-paperclip',\n  plus: 'fas fa-plus',\n  minus: 'fas fa-minus',\n}\n\nexport default icons\n","import { VuetifyIcons } from 'vuetify/types/services/icons'\n\nconst icons: VuetifyIcons = {\n  complete: 'fa fa-check',\n  cancel: 'fa fa-times-circle',\n  close: 'fa fa-times',\n  delete: 'fa fa-times-circle', // delete (e.g. v-chip close)\n  clear: 'fa fa-times-circle', // delete (e.g. v-chip close)\n  success: 'fa fa-check-circle',\n  info: 'fa fa-info-circle',\n  warning: 'fa fa-exclamation',\n  error: 'fa fa-exclamation-triangle',\n  prev: 'fa fa-chevron-left',\n  next: 'fa fa-chevron-right',\n  checkboxOn: 'fa fa-check-square',\n  checkboxOff: 'fa fa-square-o',\n  checkboxIndeterminate: 'fa fa-minus-square',\n  delimiter: 'fa fa-circle', // for carousel\n  sort: 'fa fa-sort-up',\n  expand: 'fa fa-chevron-down',\n  menu: 'fa fa-bars',\n  subgroup: 'fa fa-caret-down',\n  dropdown: 'fa fa-caret-down',\n  radioOn: 'fa fa-dot-circle-o',\n  radioOff: 'fa fa-circle-o',\n  edit: 'fa fa-pencil',\n  ratingEmpty: 'fa fa-star-o',\n  ratingFull: 'fa fa-star',\n  ratingHalf: 'fa fa-star-half-o',\n  loading: 'fa fa-refresh',\n  first: 'fa fa-step-backward',\n  last: 'fa fa-step-forward',\n  unfold: 'fa fa-angle-double-down',\n  file: 'fa fa-paperclip',\n  plus: 'fa fa-plus',\n  minus: 'fa fa-minus',\n}\n\nexport default icons\n","import { VuetifyIcons } from 'vuetify/types/services/icons'\nimport { Component } from 'vue'\nimport icons from './fa'\n\nexport function convertToComponentDeclarations (\n  component: Component | string,\n  iconSet: VuetifyIcons,\n) {\n  const result: Partial<VuetifyIcons> = {}\n\n  for (const key in iconSet) {\n    result[key] = {\n      component,\n      props: {\n        icon: (iconSet[key] as string).split(' fa-'),\n      },\n    }\n  }\n\n  return result as VuetifyIcons\n}\n\nexport default convertToComponentDeclarations('font-awesome-icon', icons)\n","import mdiSvg from './mdi-svg'\nimport md from './md'\nimport mdi from './mdi'\nimport fa from './fa'\nimport fa4 from './fa4'\nimport faSvg from './fa-svg'\n\nexport default Object.freeze({\n  mdiSvg,\n  md,\n  mdi,\n  fa,\n  fa4,\n  faSvg,\n})\n","// Extensions\nimport { Service } from '../service'\n\n// Utilities\nimport { mergeDeep } from '../../util/helpers'\n\n// Types\nimport { VuetifyPreset } from 'vuetify/types/services/presets'\nimport { Icons as IIcons } from 'vuetify/types/services/icons'\n\n// Presets\nimport presets from './presets'\n\nexport class Icons extends Service implements IIcons {\n  static property: 'icons' = 'icons'\n\n  public iconfont: IIcons['iconfont']\n\n  public values: IIcons['values']\n\n  public component: IIcons['component']\n\n  constructor (preset: VuetifyPreset) {\n    super()\n\n    const {\n      iconfont,\n      values,\n      component,\n    } = preset[Icons.property]\n\n    this.component = component\n    this.iconfont = iconfont\n    this.values = mergeDeep(\n      presets[iconfont],\n      values\n    ) as IIcons['values']\n  }\n}\n","// Extensions\nimport { Service } from '../service'\n\n// Utilities\nimport { getObjectValueByPath } from '../../util/helpers'\nimport { consoleError, consoleWarn } from '../../util/console'\n\n// Types\nimport { VuetifyPreset } from 'vuetify/types/services/presets'\nimport {\n  VuetifyLocale,\n  Lang as ILang,\n} from 'vuetify/types/services/lang'\n\nconst LANG_PREFIX = '$vuetify.'\nconst fallback = Symbol('Lang fallback')\n\nfunction getTranslation (\n  locale: VuetifyLocale,\n  key: string,\n  usingDefault = false,\n  defaultLocale: VuetifyLocale\n): string {\n  const shortKey = key.replace(LANG_PREFIX, '')\n  let translation = getObjectValueByPath(locale, shortKey, fallback) as string | typeof fallback\n\n  if (translation === fallback) {\n    if (usingDefault) {\n      consoleError(`Translation key \"${shortKey}\" not found in fallback`)\n      translation = key\n    } else {\n      consoleWarn(`Translation key \"${shortKey}\" not found, falling back to default`)\n      translation = getTranslation(defaultLocale, key, true, defaultLocale)\n    }\n  }\n\n  return translation\n}\n\nexport class Lang extends Service implements ILang {\n  static property: 'lang' = 'lang'\n\n  public current: ILang['current']\n\n  public defaultLocale = 'en'\n\n  public locales: ILang['locales']\n\n  private translator: ILang['t']\n\n  constructor (preset: VuetifyPreset) {\n    super()\n\n    const {\n      current,\n      locales,\n      t,\n    } = preset[Lang.property]\n\n    this.current = current\n    this.locales = locales\n    this.translator = t || this.defaultTranslator\n  }\n\n  public currentLocale (key: string) {\n    const translation = this.locales[this.current]\n    const defaultLocale = this.locales[this.defaultLocale]\n\n    return getTranslation(translation, key, false, defaultLocale)\n  }\n\n  public t (key: string, ...params: any[]) {\n    if (!key.startsWith(LANG_PREFIX)) return this.replace(key, params)\n\n    return this.translator(key, ...params)\n  }\n\n  private defaultTranslator (key: string, ...params: any[]) {\n    return this.replace(this.currentLocale(key), params)\n  }\n\n  private replace (str: string, params: any[]) {\n    return str.replace(/\\{(\\d+)\\}/g, (match: string, index: string) => {\n      /* istanbul ignore next */\n      return String(params[+index])\n    })\n  }\n}\n","import { ColorInt, XYZ } from '../colorUtils'\nimport { clamp } from '../../util/helpers'\n\n// For converting XYZ to sRGB\nconst srgbForwardMatrix = [\n  [3.2406, -1.5372, -0.4986],\n  [-0.9689, 1.8758, 0.0415],\n  [0.0557, -0.2040, 1.0570],\n]\n\n// Forward gamma adjust\nconst srgbForwardTransform = (C: number): number => (\n  C <= 0.0031308\n    ? C * 12.92\n    : 1.055 * C ** (1 / 2.4) - 0.055\n)\n\n// For converting sRGB to XYZ\nconst srgbReverseMatrix = [\n  [0.4124, 0.3576, 0.1805],\n  [0.2126, 0.7152, 0.0722],\n  [0.0193, 0.1192, 0.9505],\n]\n\n// Reverse gamma adjust\nconst srgbReverseTransform = (C: number): number => (\n  C <= 0.04045\n    ? C / 12.92\n    : ((C + 0.055) / 1.055) ** 2.4\n)\n\nexport function fromXYZ (xyz: XYZ): ColorInt {\n  const rgb = Array(3)\n  const transform = srgbForwardTransform\n  const matrix = srgbForwardMatrix\n\n  // Matrix transform, then gamma adjustment\n  for (let i = 0; i < 3; ++i) {\n    rgb[i] = Math.round(clamp(transform(\n      matrix[i][0] * xyz[0] +\n      matrix[i][1] * xyz[1] +\n      matrix[i][2] * xyz[2]\n    )) * 255)\n  }\n\n  // Rescale back to [0, 255]\n  return (rgb[0] << 16) + (rgb[1] << 8) + (rgb[2] << 0)\n}\n\nexport function toXYZ (rgb: ColorInt): XYZ {\n  const xyz: XYZ = [0, 0, 0]\n  const transform = srgbReverseTransform\n  const matrix = srgbReverseMatrix\n\n  // Rescale from [0, 255] to [0, 1] then adjust sRGB gamma to linear RGB\n  const r = transform((rgb >> 16 & 0xff) / 255)\n  const g = transform((rgb >> 8 & 0xff) / 255)\n  const b = transform((rgb >> 0 & 0xff) / 255)\n\n  // Matrix color space transform\n  for (let i = 0; i < 3; ++i) {\n    xyz[i] = matrix[i][0] * r + matrix[i][1] * g + matrix[i][2] * b\n  }\n\n  return xyz\n}\n","// Utilities\nimport { consoleWarn } from './console'\nimport { chunk, padEnd } from './helpers'\nimport { toXYZ } from './color/transformSRGB'\n\n// Types\nimport { VuetifyThemeVariant } from 'types/services/theme'\n\nexport type ColorInt = number\nexport type XYZ = [number, number, number]\nexport type LAB = [number, number, number]\nexport type HSV = { h: number, s: number, v: number }\nexport type HSVA = HSV & { a: number }\nexport type RGB = { r: number, g: number, b: number }\nexport type RGBA = RGB & { a: number }\nexport type HSL = { h: number, s: number, l: number }\nexport type HSLA = HSL & { a: number }\nexport type Hex = string\nexport type Hexa = string\nexport type Color = string | number | {}\n\nexport function isCssColor (color?: string | false): boolean {\n  return !!color && !!color.match(/^(#|var\\(--|(rgb|hsl)a?\\()/)\n}\n\nexport function colorToInt (color: Color): ColorInt {\n  let rgb\n\n  if (typeof color === 'number') {\n    rgb = color\n  } else if (typeof color === 'string') {\n    let c = color[0] === '#' ? color.substring(1) : color\n    if (c.length === 3) {\n      c = c.split('').map(char => char + char).join('')\n    }\n    if (c.length !== 6) {\n      consoleWarn(`'${color}' is not a valid rgb color`)\n    }\n    rgb = parseInt(c, 16)\n  } else {\n    throw new TypeError(`Colors can only be numbers or strings, recieved ${color == null ? color : color.constructor.name} instead`)\n  }\n\n  if (rgb < 0) {\n    consoleWarn(`Colors cannot be negative: '${color}'`)\n    rgb = 0\n  } else if (rgb > 0xffffff || isNaN(rgb)) {\n    consoleWarn(`'${color}' is not a valid rgb color`)\n    rgb = 0xffffff\n  }\n\n  return rgb\n}\n\nexport function classToHex (\n  color: string,\n  colors: Record<string, Record<string, string>>,\n  currentTheme: Partial<VuetifyThemeVariant>,\n): string {\n  const [colorName, colorModifier] = color\n    .toString().trim().replace('-', '').split(' ', 2) as (string | undefined)[]\n\n  let hexColor = ''\n  if (colorName && colorName in colors) {\n    if (colorModifier && colorModifier in colors[colorName]) {\n      hexColor = colors[colorName][colorModifier]\n    } else if ('base' in colors[colorName]) {\n      hexColor = colors[colorName].base\n    }\n  } else if (colorName && colorName in currentTheme) {\n    hexColor = currentTheme[colorName] as string\n  }\n\n  return hexColor\n}\n\nexport function intToHex (color: ColorInt): string {\n  let hexColor: string = color.toString(16)\n\n  if (hexColor.length < 6) hexColor = '0'.repeat(6 - hexColor.length) + hexColor\n\n  return '#' + hexColor\n}\n\nexport function colorToHex (color: Color): string {\n  return intToHex(colorToInt(color))\n}\n\n/**\n * Converts HSVA to RGBA. Based on formula from https://en.wikipedia.org/wiki/HSL_and_HSV\n *\n * @param color HSVA color as an array [0-360, 0-1, 0-1, 0-1]\n */\nexport function HSVAtoRGBA (hsva: HSVA): RGBA {\n  const { h, s, v, a } = hsva\n  const f = (n: number) => {\n    const k = (n + (h / 60)) % 6\n    return v - v * s * Math.max(Math.min(k, 4 - k, 1), 0)\n  }\n\n  const rgb = [f(5), f(3), f(1)].map(v => Math.round(v * 255))\n\n  return { r: rgb[0], g: rgb[1], b: rgb[2], a }\n}\n\n/**\n * Converts RGBA to HSVA. Based on formula from https://en.wikipedia.org/wiki/HSL_and_HSV\n *\n * @param color RGBA color as an array [0-255, 0-255, 0-255, 0-1]\n */\nexport function RGBAtoHSVA (rgba: RGBA): HSVA {\n  if (!rgba) return { h: 0, s: 1, v: 1, a: 1 }\n\n  const r = rgba.r / 255\n  const g = rgba.g / 255\n  const b = rgba.b / 255\n  const max = Math.max(r, g, b)\n  const min = Math.min(r, g, b)\n\n  let h = 0\n\n  if (max !== min) {\n    if (max === r) {\n      h = 60 * (0 + ((g - b) / (max - min)))\n    } else if (max === g) {\n      h = 60 * (2 + ((b - r) / (max - min)))\n    } else if (max === b) {\n      h = 60 * (4 + ((r - g) / (max - min)))\n    }\n  }\n\n  if (h < 0) h = h + 360\n\n  const s = max === 0 ? 0 : (max - min) / max\n  const hsv = [h, s, max]\n\n  return { h: hsv[0], s: hsv[1], v: hsv[2], a: rgba.a }\n}\n\nexport function HSVAtoHSLA (hsva: HSVA): HSLA {\n  const { h, s, v, a } = hsva\n\n  const l = v - (v * s / 2)\n\n  const sprime = l === 1 || l === 0 ? 0 : (v - l) / Math.min(l, 1 - l)\n\n  return { h, s: sprime, l, a }\n}\n\nexport function HSLAtoHSVA (hsl: HSLA): HSVA {\n  const { h, s, l, a } = hsl\n\n  const v = l + s * Math.min(l, 1 - l)\n\n  const sprime = v === 0 ? 0 : 2 - (2 * l / v)\n\n  return { h, s: sprime, v, a }\n}\n\nexport function RGBAtoCSS (rgba: RGBA): string {\n  return `rgba(${rgba.r}, ${rgba.g}, ${rgba.b}, ${rgba.a})`\n}\n\nexport function RGBtoCSS (rgba: RGBA): string {\n  return RGBAtoCSS({ ...rgba, a: 1 })\n}\n\nexport function RGBAtoHex (rgba: RGBA): Hex {\n  const toHex = (v: number) => {\n    const h = Math.round(v).toString(16)\n    return ('00'.substr(0, 2 - h.length) + h).toUpperCase()\n  }\n\n  return `#${[\n    toHex(rgba.r),\n    toHex(rgba.g),\n    toHex(rgba.b),\n    toHex(Math.round(rgba.a * 255)),\n  ].join('')}`\n}\n\nexport function HexToRGBA (hex: Hex): RGBA {\n  const rgba = chunk(hex.slice(1), 2).map((c: string) => parseInt(c, 16))\n\n  return {\n    r: rgba[0],\n    g: rgba[1],\n    b: rgba[2],\n    a: Math.round((rgba[3] / 255) * 100) / 100,\n  }\n}\n\nexport function HexToHSVA (hex: Hex): HSVA {\n  const rgb = HexToRGBA(hex)\n  return RGBAtoHSVA(rgb)\n}\n\nexport function HSVAtoHex (hsva: HSVA): Hex {\n  return RGBAtoHex(HSVAtoRGBA(hsva))\n}\n\nexport function parseHex (hex: string): Hex {\n  if (hex.startsWith('#')) {\n    hex = hex.slice(1)\n  }\n\n  hex = hex.replace(/([^0-9a-f])/gi, 'F')\n\n  if (hex.length === 3 || hex.length === 4) {\n    hex = hex.split('').map(x => x + x).join('')\n  }\n\n  if (hex.length === 6) {\n    hex = padEnd(hex, 8, 'F')\n  } else {\n    hex = padEnd(padEnd(hex, 6), 8, 'F')\n  }\n\n  return `#${hex}`.toUpperCase().substr(0, 9)\n}\n\nexport function parseGradient (\n  gradient: string,\n  colors: Record<string, Record<string, string>>,\n  currentTheme: Partial<VuetifyThemeVariant>,\n) {\n  return gradient.replace(/([a-z]+(\\s[a-z]+-[1-5])?)(?=$|,)/gi, x => {\n    return classToHex(x, colors, currentTheme) || x\n  }).replace(/(rgba\\()#[0-9a-f]+(?=,)/gi, x => {\n    return 'rgba(' + Object.values(HexToRGBA(parseHex(x.replace(/rgba\\(/, '')))).slice(0, 3).join(',')\n  })\n}\n\nexport function RGBtoInt (rgba: RGBA): ColorInt {\n  return (rgba.r << 16) + (rgba.g << 8) + rgba.b\n}\n\n/**\n * Returns the contrast ratio (1-21) between two colors.\n *\n * @param c1 First color\n * @param c2 Second color\n */\nexport function contrastRatio (c1: RGBA, c2: RGBA): number {\n  const [, y1] = toXYZ(RGBtoInt(c1))\n  const [, y2] = toXYZ(RGBtoInt(c2))\n\n  return (Math.max(y1, y2) + 0.05) / (Math.min(y1, y2) + 0.05)\n}\n","import { XYZ, LAB } from '../colorUtils'\n\nconst delta = 0.20689655172413793 // 629\n\nconst cielabForwardTransform = (t: number): number => (\n  t > delta ** 3\n    ? Math.cbrt(t)\n    : (t / (3 * delta ** 2)) + 4 / 29\n)\n\nconst cielabReverseTransform = (t: number): number => (\n  t > delta\n    ? t ** 3\n    : (3 * delta ** 2) * (t - 4 / 29)\n)\n\nexport function fromXYZ (xyz: XYZ): LAB {\n  const transform = cielabForwardTransform\n  const transformedY = transform(xyz[1])\n\n  return [\n    116 * transformedY - 16,\n    500 * (transform(xyz[0] / 0.95047) - transformedY),\n    200 * (transformedY - transform(xyz[2] / 1.08883)),\n  ]\n}\n\nexport function toXYZ (lab: LAB): XYZ {\n  const transform = cielabReverseTransform\n  const Ln = (lab[0] + 16) / 116\n  return [\n    transform(Ln + lab[1] / 500) * 0.95047,\n    transform(Ln),\n    transform(Ln - lab[2] / 200) * 1.08883,\n  ]\n}\n","import { keys } from '../../util/helpers'\nimport { colorToInt, intToHex, colorToHex, ColorInt } from '../../util/colorUtils'\nimport * as sRGB from '../../util/color/transformSRGB'\nimport * as LAB from '../../util/color/transformCIELAB'\nimport {\n  VuetifyParsedTheme,\n  VuetifyThemeItem,\n} from 'vuetify/types/services/theme'\n\nexport function parse (\n  theme: Record<string, VuetifyThemeItem>,\n  isItem = false,\n  variations = true,\n): VuetifyParsedTheme {\n  const { anchor, ...variant } = theme\n  const colors = Object.keys(variant)\n  const parsedTheme: any = {}\n\n  for (let i = 0; i < colors.length; ++i) {\n    const name = colors[i]\n    const value = theme[name]\n\n    if (value == null) continue\n\n    if (!variations) {\n      parsedTheme[name] = { base: intToHex(colorToInt(value)) }\n    } else if (isItem) {\n      /* istanbul ignore else */\n      if (name === 'base' || name.startsWith('lighten') || name.startsWith('darken')) {\n        parsedTheme[name] = colorToHex(value)\n      }\n    } else if (typeof value === 'object') {\n      parsedTheme[name] = parse(value, true, variations)\n    } else {\n      parsedTheme[name] = genVariations(name, colorToInt(value))\n    }\n  }\n\n  if (!isItem) {\n    parsedTheme.anchor = anchor || parsedTheme.base || parsedTheme.primary.base\n  }\n\n  return parsedTheme\n}\n\n/**\n * Generate the CSS for a base color (.primary)\n */\nconst genBaseColor = (name: string, value: string): string => {\n  return `\n.v-application .${name} {\n  background-color: ${value} !important;\n  border-color: ${value} !important;\n}\n.v-application .${name}--text {\n  color: ${value} !important;\n  caret-color: ${value} !important;\n}`\n}\n\n/**\n * Generate the CSS for a variant color (.primary.darken-2)\n */\nconst genVariantColor = (name: string, variant: string, value: string): string => {\n  const [type, n] = variant.split(/(\\d)/, 2)\n  return `\n.v-application .${name}.${type}-${n} {\n  background-color: ${value} !important;\n  border-color: ${value} !important;\n}\n.v-application .${name}--text.text--${type}-${n} {\n  color: ${value} !important;\n  caret-color: ${value} !important;\n}`\n}\n\nconst genColorVariableName = (name: string, variant = 'base'): string => `--v-${name}-${variant}`\n\nconst genColorVariable = (name: string, variant = 'base'): string => `var(${genColorVariableName(name, variant)})`\n\nexport function genStyles (theme: VuetifyParsedTheme, cssVar = false): string {\n  const { anchor, ...variant } = theme\n  const colors = Object.keys(variant)\n\n  if (!colors.length) return ''\n\n  let variablesCss = ''\n  let css = ''\n\n  const aColor = cssVar ? genColorVariable('anchor') : anchor\n  css += `.v-application a { color: ${aColor}; }`\n  cssVar && (variablesCss += `  ${genColorVariableName('anchor')}: ${anchor};\\n`)\n\n  for (let i = 0; i < colors.length; ++i) {\n    const name = colors[i]\n    const value = theme[name]\n\n    css += genBaseColor(name, cssVar ? genColorVariable(name) : value.base)\n    cssVar && (variablesCss += `  ${genColorVariableName(name)}: ${value.base};\\n`)\n\n    const variants = keys(value)\n    for (let i = 0; i < variants.length; ++i) {\n      const variant = variants[i]\n      const variantValue = value[variant]\n      if (variant === 'base') continue\n\n      css += genVariantColor(name, variant, cssVar ? genColorVariable(name, variant) : variantValue)\n      cssVar && (variablesCss += `  ${genColorVariableName(name, variant)}: ${variantValue};\\n`)\n    }\n  }\n\n  if (cssVar) {\n    variablesCss = `:root {\\n${variablesCss}}\\n\\n`\n  }\n\n  return variablesCss + css\n}\n\nexport function genVariations (name: string, value: ColorInt): Record<string, string> {\n  const values: Record<string, string> = {\n    base: intToHex(value),\n  }\n\n  for (let i = 5; i > 0; --i) {\n    values[`lighten${i}`] = intToHex(lighten(value, i))\n  }\n\n  for (let i = 1; i <= 4; ++i) {\n    values[`darken${i}`] = intToHex(darken(value, i))\n  }\n\n  return values\n}\n\nexport function lighten (value: ColorInt, amount: number): ColorInt {\n  const lab = LAB.fromXYZ(sRGB.toXYZ(value))\n  lab[0] = lab[0] + amount * 10\n  return sRGB.fromXYZ(LAB.toXYZ(lab))\n}\n\nexport function darken (value: ColorInt, amount: number): ColorInt {\n  const lab = LAB.fromXYZ(sRGB.toXYZ(value))\n  lab[0] = lab[0] - amount * 10\n  return sRGB.fromXYZ(LAB.toXYZ(lab))\n}\n","/* eslint-disable no-multi-spaces */\n// Extensions\nimport { Service } from '../service'\n\n// Utilities\nimport * as ThemeUtils from './utils'\nimport { getNestedValue } from '../../util/helpers'\n\n// Types\nimport Vue from 'vue'\nimport { VuetifyPreset } from 'vuetify/types/services/presets'\nimport {\n  VuetifyParsedTheme,\n  VuetifyThemes,\n  VuetifyThemeVariant,\n  Theme as ITheme,\n} from 'vuetify/types/services/theme'\n\nexport class Theme extends Service {\n  static property: 'theme' = 'theme'\n\n  public disabled = false\n\n  public options: ITheme['options']\n\n  public styleEl?: HTMLStyleElement\n\n  public themes: VuetifyThemes\n\n  public defaults: VuetifyThemes\n\n  private isDark = null as boolean | null\n\n  private unwatch = null as (() => void) | null\n\n  private vueMeta = null as any | null\n\n  constructor (preset: VuetifyPreset) {\n    super()\n\n    const {\n      dark,\n      disable,\n      options,\n      themes,\n    } = preset[Theme.property]\n\n    this.dark = Boolean(dark)\n    this.defaults = this.themes = themes\n    this.options = options\n\n    if (disable) {\n      this.disabled = true\n\n      return\n    }\n\n    this.themes = {\n      dark: this.fillVariant(themes.dark, true),\n      light: this.fillVariant(themes.light, false),\n    }\n  }\n\n  // When setting css, check for element and apply new values\n  /* eslint-disable-next-line accessor-pairs */\n  set css (val: string) {\n    if (this.vueMeta) {\n      if (this.isVueMeta23) {\n        this.applyVueMeta23()\n      }\n      return\n    }\n    this.checkOrCreateStyleElement() && (this.styleEl!.innerHTML = val)\n  }\n\n  set dark (val: boolean) {\n    const oldDark = this.isDark\n\n    this.isDark = val\n    // Only apply theme after dark\n    // has already been set before\n    oldDark != null && this.applyTheme()\n  }\n\n  get dark () {\n    return Boolean(this.isDark)\n  }\n\n  // Apply current theme default\n  // only called on client side\n  public applyTheme (): void {\n    if (this.disabled) return this.clearCss()\n\n    this.css = this.generatedStyles\n  }\n\n  public clearCss (): void {\n    this.css = ''\n  }\n\n  // Initialize theme for SSR and SPA\n  // Attach to ssrContext head or\n  // apply new theme to document\n  public init (root: Vue, ssrContext?: any): void {\n    if (this.disabled) return\n\n    /* istanbul ignore else */\n    if ((root as any).$meta) {\n      this.initVueMeta(root)\n    } else if (ssrContext) {\n      this.initSSR(ssrContext)\n    }\n\n    this.initTheme(root)\n  }\n\n  // Allows for you to set target theme\n  public setTheme (theme: 'light' | 'dark', value: object) {\n    this.themes[theme] = Object.assign(this.themes[theme], value)\n    this.applyTheme()\n  }\n\n  // Reset theme defaults\n  public resetThemes () {\n    this.themes.light = Object.assign({}, this.defaults.light)\n    this.themes.dark = Object.assign({}, this.defaults.dark)\n    this.applyTheme()\n  }\n\n  // Check for existence of style element\n  private checkOrCreateStyleElement (): boolean {\n    this.styleEl = document.getElementById('vuetify-theme-stylesheet') as HTMLStyleElement\n\n    /* istanbul ignore next */\n    if (this.styleEl) return true\n\n    this.genStyleElement() // If doesn't have it, create it\n\n    return Boolean(this.styleEl)\n  }\n\n  private fillVariant (\n    theme: Partial<VuetifyThemeVariant> = {},\n    dark: boolean\n  ): VuetifyThemeVariant {\n    const defaultTheme = this.themes[dark ? 'dark' : 'light']\n\n    return Object.assign({},\n      defaultTheme,\n      theme\n    )\n  }\n\n  // Generate the style element\n  // if applicable\n  private genStyleElement (): void {\n    /* istanbul ignore if */\n    if (typeof document === 'undefined') return\n\n    /* istanbul ignore next */\n    this.styleEl = document.createElement('style')\n    this.styleEl.type = 'text/css'\n    this.styleEl.id = 'vuetify-theme-stylesheet'\n\n    if (this.options.cspNonce) {\n      this.styleEl.setAttribute('nonce', this.options.cspNonce)\n    }\n\n    document.head.appendChild(this.styleEl)\n  }\n\n  private initVueMeta (root: any) {\n    this.vueMeta = root.$meta()\n    if (this.isVueMeta23) {\n      // vue-meta needs to apply after mounted()\n      root.$nextTick(() => {\n        this.applyVueMeta23()\n      })\n      return\n    }\n\n    const metaKeyName = typeof this.vueMeta.getOptions === 'function' ? this.vueMeta.getOptions().keyName : 'metaInfo'\n    const metaInfo = root.$options[metaKeyName] || {}\n\n    root.$options[metaKeyName] = () => {\n      metaInfo.style = metaInfo.style || []\n\n      const vuetifyStylesheet = metaInfo.style.find((s: any) => s.id === 'vuetify-theme-stylesheet')\n\n      if (!vuetifyStylesheet) {\n        metaInfo.style.push({\n          cssText: this.generatedStyles,\n          type: 'text/css',\n          id: 'vuetify-theme-stylesheet',\n          nonce: (this.options || {}).cspNonce,\n        })\n      } else {\n        vuetifyStylesheet.cssText = this.generatedStyles\n      }\n\n      return metaInfo\n    }\n  }\n\n  private applyVueMeta23 () {\n    const { set } = this.vueMeta.addApp('vuetify')\n\n    set({\n      style: [{\n        cssText: this.generatedStyles,\n        type: 'text/css',\n        id: 'vuetify-theme-stylesheet',\n        nonce: this.options.cspNonce,\n      }],\n    })\n  }\n\n  private initSSR (ssrContext?: any) {\n    // SSR\n    const nonce = this.options.cspNonce ? ` nonce=\"${this.options.cspNonce}\"` : ''\n    ssrContext.head = ssrContext.head || ''\n    ssrContext.head += `<style type=\"text/css\" id=\"vuetify-theme-stylesheet\"${nonce}>${this.generatedStyles}</style>`\n  }\n\n  private initTheme (root: Vue) {\n    // Only watch for reactivity on client side\n    if (typeof document === 'undefined') return\n\n    // If we get here somehow, ensure\n    // existing instance is removed\n    if (this.unwatch) {\n      this.unwatch()\n      this.unwatch = null\n    }\n\n    // TODO: Update to use RFC if merged\n    // https://github.com/vuejs/rfcs/blob/advanced-reactivity-api/active-rfcs/0000-advanced-reactivity-api.md\n    root.$once('hook:created', () => {\n      const obs = Vue.observable({ themes: this.themes })\n      this.unwatch = root.$watch(() => obs.themes, () => this.applyTheme(), { deep: true })\n    })\n    this.applyTheme()\n  }\n\n  get currentTheme () {\n    const target = this.dark ? 'dark' : 'light'\n\n    return this.themes[target]\n  }\n\n  get generatedStyles (): string {\n    const theme = this.parsedTheme\n    /* istanbul ignore next */\n    const options = this.options || {}\n    let css\n\n    if (options.themeCache != null) {\n      css = options.themeCache.get(theme)\n      /* istanbul ignore if */\n      if (css != null) return css\n    }\n\n    css = ThemeUtils.genStyles(theme, options.customProperties)\n\n    if (options.minifyTheme != null) {\n      css = options.minifyTheme(css)\n    }\n\n    if (options.themeCache != null) {\n      options.themeCache.set(theme, css)\n    }\n\n    return css\n  }\n\n  get parsedTheme (): VuetifyParsedTheme {\n    return ThemeUtils.parse(\n      this.currentTheme || {},\n      undefined,\n      getNestedValue(this.options, ['variations'], true)\n    )\n  }\n\n  // Is using v2.3 of vue-meta\n  // https://github.com/nuxt/vue-meta/releases/tag/v2.3.0\n  private get isVueMeta23 (): boolean {\n    return typeof this.vueMeta.addApp === 'function'\n  }\n}\n","import { install } from './install'\n\n// Types\nimport Vue from 'vue'\nimport {\n  UserVuetifyPreset,\n  VuetifyPreset,\n} from 'vuetify/types/services/presets'\nimport {\n  VuetifyService,\n  VuetifyServiceContract,\n} from 'vuetify/types/services'\n\n// Services\nimport * as services from './services'\n\nexport default class Vuetify {\n  static install = install\n\n  static installed = false\n\n  static version = __VUETIFY_VERSION__\n\n  static config = {\n    silent: false,\n  }\n\n  public framework: Dictionary<VuetifyServiceContract> = {\n    isHydrating: false,\n  } as any\n\n  public installed: string[] = []\n\n  public preset = {} as VuetifyPreset\n\n  public userPreset: UserVuetifyPreset = {}\n\n  constructor (userPreset: UserVuetifyPreset = {}) {\n    this.userPreset = userPreset\n\n    this.use(services.Presets)\n    this.use(services.Application)\n    this.use(services.Breakpoint)\n    this.use(services.Goto)\n    this.use(services.Icons)\n    this.use(services.Lang)\n    this.use(services.Theme)\n  }\n\n  // Called on the new vuetify instance\n  // bootstrap in install beforeCreate\n  // Exposes ssrContext if available\n  init (root: Vue, ssrContext?: object) {\n    this.installed.forEach(property => {\n      const service = this.framework[property]\n\n      service.framework = this.framework\n\n      service.init(root, ssrContext)\n    })\n\n    // rtl is not installed and\n    // will never be called by\n    // the init process\n    this.framework.rtl = Boolean(this.preset.rtl) as any\n  }\n\n  // Instantiate a VuetifyService\n  use (Service: VuetifyService) {\n    const property = Service.property\n\n    if (this.installed.includes(property)) return\n\n    // TODO maybe a specific type for arg 2?\n    this.framework[property] = new Service(this.preset, this as any)\n    this.installed.push(property)\n  }\n}\n","export default {\"theme\":{\"light\":true,\"themes\":{\"light\":{\"primary\":\"#252733\",\"secondary\":\"#0073c0\",\"accent\":\"#82B1FF\",\"error\":\"#FF5252\",\"info\":\"#2196F3\",\"success\":\"#4CAF50\",\"warning\":\"#FFC107\",\"danger\":\"#FF5252\"}}}}\n","import Vue from 'vue'\nimport Vuetify from 'vuetify/lib/framework'\n\nimport options from './options'\n\nVue.use(Vuetify, {\n})\n\nexport default (ctx) => {\n  const vuetifyOptions = typeof options === 'function' ? options(ctx) : options\n\n  const vuetify = new Vuetify(vuetifyOptions)\n\n  ctx.app.vuetify = vuetify\n  ctx.$vuetify = vuetify.framework\n}\n","import isHTTPS from 'is-https'\nimport { hasProtocol } from '~i18n-ufo'\nimport { localeMessages, options } from './options'\nimport { formatMessage } from './utils-common'\n\n/** @typedef {import('../../types/internal').ResolvedOptions} ResolvedOptions */\n\n/**\n * Asynchronously load messages from translation files\n *\n * @param {import('@nuxt/types').Context} context\n * @param {string} locale Language code to load\n * @return {Promise<void>}\n */\nexport async function loadLanguageAsync (context, locale) {\n  const { app } = context\n  const { i18n } = app\n\n  if (!i18n.loadedLanguages) {\n    i18n.loadedLanguages = []\n  }\n\n  if (!i18n.loadedLanguages.includes(locale)) {\n    const localeObject = options.normalizedLocales.find(l => l.code === locale)\n    if (localeObject) {\n      const { file } = localeObject\n      if (file) {\n        /*  */\n      } else {\n        console.warn(formatMessage(`Could not find lang file for locale ${locale}`))\n      }\n    } else {\n      console.warn(formatMessage(`Attempted to load messages for non-existant locale code \"${locale}\"`))\n    }\n  }\n}\n\n/**\n * Resolves base URL value if provided as function. Otherwise just returns verbatim.\n *\n * @param {string | ((context: import('@nuxt/types').Context) => string)} baseUrl\n * @param {import('@nuxt/types').Context} context\n * @param {import('../../types').Locale} localeCode\n * @param {Pick<ResolvedOptions, 'differentDomains' | 'normalizedLocales'>} options\n * @return {string}\n */\nexport function resolveBaseUrl (baseUrl, context, localeCode, { differentDomains, normalizedLocales }) {\n  if (typeof baseUrl === 'function') {\n    return baseUrl(context)\n  }\n\n  if (differentDomains && localeCode) {\n    // Lookup the `differentDomain` origin associated with given locale.\n    const domain = getDomainFromLocale(localeCode, context.req, { normalizedLocales })\n    if (domain) {\n      return domain\n    }\n  }\n\n  return baseUrl\n}\n\n/**\n * Gets the `differentDomain` domain from locale.\n *\n * @param {string} localeCode\n * @param {import('http').IncomingMessage | undefined} req\n * @param {Pick<ResolvedOptions, 'normalizedLocales'>} options\n * @return {string | undefined}\n */\nexport function getDomainFromLocale (localeCode, req, { normalizedLocales }) {\n// Lookup the `differentDomain` origin associated with given locale.\n  const lang = normalizedLocales.find(locale => locale.code === localeCode)\n  if (lang && lang.domain) {\n    if (hasProtocol(lang.domain)) {\n      return lang.domain\n    }\n    let protocol\n    if (process.server) {\n      protocol = (req && isHTTPS(req)) ? 'https' : 'http'\n    } else {\n      protocol = window.location.protocol.split(':')[0]\n    }\n    return `${protocol}://${lang.domain}`\n  }\n\n  // eslint-disable-next-line no-console\n  console.warn(formatMessage(`Could not find domain name for locale ${localeCode}`))\n}\n\n/**\n * @param {import('vuex').Store<Record<string, boolean>>} store\n * @param {Required<import('../../types').VuexOptions>} vuex\n * @param {readonly string[]} localeCodes\n */\nexport function registerStore (store, vuex, localeCodes) {\n  /** @typedef {{\n   *    locale?: string\n   *    messages?: Record<string, string>\n   *    routeParams?: Record<string, Record<string, string>>\n   * }} ModuleStore\n   *\n   * @type {import('vuex').Module<ModuleStore, {}>}\n   */\n  const storeModule = {\n    namespaced: true,\n    state: () => ({\n      ...(vuex.syncRouteParams ? { routeParams: {} } : {})\n    }),\n    actions: {\n      ...(vuex.syncRouteParams\n        ? {\n            setRouteParams ({ commit }, params) {\n              if (process.env.NODE_ENV === 'development') {\n                validateRouteParams(params, localeCodes)\n              }\n              commit('setRouteParams', params)\n            }\n          }\n        : {})\n    },\n    mutations: {\n      ...(vuex.syncRouteParams\n        ? {\n            setRouteParams (state, params) {\n              state.routeParams = params\n            }\n          }\n        : {})\n    },\n    getters: {\n      ...(vuex.syncRouteParams\n        ? {\n            localeRouteParams: ({ routeParams }) => {\n              /** @type {(locale: string) => Record<string, string>} */\n              const paramsGetter = locale => (routeParams && routeParams[locale]) || {}\n              return paramsGetter\n            }\n          }\n        : {})\n    }\n  }\n  store.registerModule(vuex.moduleName, storeModule, { preserveState: !!store.state[vuex.moduleName] })\n}\n\n/**\n * Validate setRouteParams action's payload\n *\n * @param {object} routeParams The action's payload\n * @param {readonly string[]} localeCodes\n */\nexport function validateRouteParams (routeParams, localeCodes) {\n  if (!isObject(routeParams)) {\n    // eslint-disable-next-line no-console\n    console.warn(formatMessage('Route params should be an object'))\n    return\n  }\n\n  for (const [key, value] of Object.entries(routeParams)) {\n    if (!localeCodes.includes(key)) {\n    // eslint-disable-next-line no-console\n      console.warn(formatMessage(`Trying to set route params for key ${key} which is not a valid locale`))\n    } else if (!isObject(value)) {\n    // eslint-disable-next-line no-console\n      console.warn(formatMessage(`Trying to set route params for locale ${key} with a non-object value`))\n    }\n  }\n}\n\n/**\n * Merge external additional messages\n *\n * @param {import('../../types').NuxtI18nInstance} i18n\n * @param {ResolvedOptions['additionalMessages']} additionalMessages\n * @param {ResolvedOptions['localeCodes']} localeCodes\n * @param {string[] | null} [onlyLocales=null]\n * @return {void}\n */\nexport function mergeAdditionalMessages (i18n, additionalMessages, localeCodes, onlyLocales) {\n  const locales = onlyLocales || localeCodes\n  for (const additionalEntry of additionalMessages) {\n    for (const locale of locales) {\n      const existingMessages = i18n.getLocaleMessage(locale)\n      i18n.mergeLocaleMessage(locale, additionalEntry[locale])\n      i18n.mergeLocaleMessage(locale, existingMessages)\n    }\n  }\n}\n\n/**\n * @param {any} value\n * @return {boolean}\n */\nfunction isObject (value) {\n  return value && !Array.isArray(value) && typeof value === 'object'\n}\n","// @ts-ignore\nimport nuxtMiddleware from '../middleware'\n\n/** @type {import('@nuxt/types').Middleware} */\nconst i18nMiddleware = async (context) => {\n  const { app, isHMR } = context\n\n  if (isHMR) {\n    return\n  }\n\n  const [status, redirectPath, preserveQuery] = await app.i18n.__onNavigate(context.route)\n  if (status && redirectPath) {\n    const query = preserveQuery ? context.route.query : undefined\n    context.redirect(status, redirectPath, query)\n  }\n}\n\nnuxtMiddleware.nuxti18n = i18nMiddleware\n","import './middleware'\nimport Vue from 'vue'\nimport { withoutTrailingSlash, withTrailingSlash } from '~i18n-ufo'\nimport { Constants, nuxtOptions, options } from './options'\nimport { getDomainFromLocale } from './plugin.utils'\n\n/**\n * @this {import('../../types/internal').PluginProxy}\n * @type {Vue['localePath']}\n */\nfunction localePath (route, locale) {\n  const localizedRoute = resolveRoute.call(this, route, locale)\n  return localizedRoute ? localizedRoute.route.redirectedFrom || localizedRoute.route.fullPath : ''\n}\n\n/**\n * @this {import('../../types/internal').PluginProxy}\n * @type {Vue['localeRoute']}\n */\nfunction localeRoute (route, locale) {\n  const resolved = resolveRoute.call(this, route, locale)\n  return resolved ? resolved.route : undefined\n}\n\n/**\n * @this {import('../../types/internal').PluginProxy}\n * @type {Vue['localeLocation']}\n */\nfunction localeLocation (route, locale) {\n  const resolved = resolveRoute.call(this, route, locale)\n  return resolved ? resolved.location : undefined\n}\n\n/**\n * @this {import('../../types/internal').PluginProxy}\n * @param {import('vue-router').RawLocation} route\n * @param {string} [locale]\n * @return {ReturnType<import('vue-router').default['resolve']> | undefined}\n */\nfunction resolveRoute (route, locale) {\n  // Abort if no route or no locale\n  if (!route) {\n    return\n  }\n\n  const { i18n } = this\n\n  locale = locale || i18n.locale\n\n  if (!locale) {\n    return\n  }\n\n  // If route parameter is a string, check if it's a path or name of route.\n  if (typeof route === 'string') {\n    if (route[0] === '/') {\n      // If route parameter is a path, create route object with path.\n      route = { path: route }\n    } else {\n      // Else use it as route name.\n      route = { name: route }\n    }\n  }\n\n  let localizedRoute = Object.assign({}, route)\n\n  if (localizedRoute.path && !localizedRoute.name) {\n    const resolvedRoute = this.router.resolve(localizedRoute).route\n    const resolvedRouteName = this.getRouteBaseName(resolvedRoute)\n    if (resolvedRouteName) {\n      localizedRoute = {\n        name: getLocaleRouteName(resolvedRouteName, locale),\n        params: resolvedRoute.params,\n        query: resolvedRoute.query,\n        hash: resolvedRoute.hash\n      }\n    } else {\n      const isDefaultLocale = locale === options.defaultLocale\n      // if route has a path defined but no name, resolve full route using the path\n      const isPrefixed =\n          // don't prefix default locale\n          !(isDefaultLocale && [Constants.STRATEGIES.PREFIX_EXCEPT_DEFAULT, Constants.STRATEGIES.PREFIX_AND_DEFAULT].includes(options.strategy)) &&\n          // no prefix for any language\n          !(options.strategy === Constants.STRATEGIES.NO_PREFIX) &&\n          // no prefix for different domains\n          !i18n.differentDomains\n      if (isPrefixed) {\n        localizedRoute.path = `/${locale}${localizedRoute.path}`\n      }\n      localizedRoute.path = nuxtOptions.trailingSlash ? withTrailingSlash(localizedRoute.path, true) : withoutTrailingSlash(localizedRoute.path, true)\n    }\n  } else {\n    if (!localizedRoute.name && !localizedRoute.path) {\n      localizedRoute.name = this.getRouteBaseName()\n    }\n\n    localizedRoute.name = getLocaleRouteName(localizedRoute.name, locale)\n\n    const { params } = localizedRoute\n    if (params && params['0'] === undefined && params.pathMatch) {\n      params['0'] = params.pathMatch\n    }\n  }\n\n  const resolvedRoute = this.router.resolve(localizedRoute)\n  if (resolvedRoute.route.name) {\n    return resolvedRoute\n  }\n  // If didn't resolve to an existing route then just return resolved route based on original input.\n  return this.router.resolve(route)\n}\n\n/**\n * @this {import('../../types/internal').PluginProxy}\n * @type {Vue['switchLocalePath']}\n */\nfunction switchLocalePath (locale) {\n  const name = this.getRouteBaseName()\n  if (!name) {\n    return ''\n  }\n\n  const { i18n, route, store } = this\n  const { params, ...routeCopy } = route\n  let langSwitchParams = {}\n  if (options.vuex && options.vuex.syncRouteParams && store) {\n    langSwitchParams = store.getters[`${options.vuex.moduleName}/localeRouteParams`](locale)\n  }\n  const baseRoute = Object.assign({}, routeCopy, {\n    name,\n    params: {\n      ...params,\n      ...langSwitchParams,\n      0: params.pathMatch\n    }\n  })\n  let path = this.localePath(baseRoute, locale)\n\n  // Handle different domains\n  if (i18n.differentDomains) {\n    const getDomainOptions = {\n      differentDomains: i18n.differentDomains,\n      normalizedLocales: options.normalizedLocales\n    }\n    const domain = getDomainFromLocale(locale, this.req, getDomainOptions)\n    if (domain) {\n      path = domain + path\n    }\n  }\n\n  return path\n}\n\n/**\n * @this {import('../../types/internal').PluginProxy}\n * @type {Vue['getRouteBaseName']}\n */\nfunction getRouteBaseName (givenRoute) {\n  const route = givenRoute !== undefined ? givenRoute : this.route\n  if (!route || !route.name) {\n    return\n  }\n  return route.name.split(options.routesNameSeparator)[0]\n}\n\n/**\n * @param {string | undefined} routeName\n * @param {string} locale\n */\nfunction getLocaleRouteName (routeName, locale) {\n  let name = routeName + (options.strategy === Constants.STRATEGIES.NO_PREFIX ? '' : options.routesNameSeparator + locale)\n\n  if (locale === options.defaultLocale && options.strategy === Constants.STRATEGIES.PREFIX_AND_DEFAULT) {\n    name += options.routesNameSeparator + options.defaultLocaleRouteNameSuffix\n  }\n\n  return name\n}\n\n/**\n * @template {(...args: any[]) => any} T\n * @param {T} targetFunction\n * @return {(this: Vue, ...args: Parameters<T>) => ReturnType<T>}\n */\nconst VueInstanceProxy = function (targetFunction) {\n  return function () {\n    const proxy = {\n      getRouteBaseName: this.getRouteBaseName,\n      i18n: this.$i18n,\n      localePath: this.localePath,\n      localeRoute: this.localeRoute,\n      localeLocation: this.localeLocation,\n      // @ts-ignore\n      req: process.server ? this.$root.context?.req || this.$ssrContext?.req : null,\n      route: this.$route,\n      router: this.$router,\n      store: this.$store\n    }\n\n    return targetFunction.call(proxy, ...arguments)\n  }\n}\n\n/**\n * @template {(...args: any[]) => any} T\n * @param {import('@nuxt/types').Context} context\n * @param {T} targetFunction\n * @return {(...args: Parameters<T>) => ReturnType<T>}\n */\nconst NuxtContextProxy = function (context, targetFunction) {\n  return function () {\n    const { app, req, route, store } = context\n\n    const proxy = {\n      getRouteBaseName: app.getRouteBaseName,\n      i18n: app.i18n,\n      localePath: app.localePath,\n      localeLocation: app.localeLocation,\n      localeRoute: app.localeRoute,\n      req: process.server ? req : null,\n      route,\n      router: app.router,\n      store\n    }\n\n    return targetFunction.call(proxy, ...arguments)\n  }\n}\n\n/** @type {import('vue').PluginObject<void>} */\nconst plugin = {\n  install (Vue) {\n    Vue.mixin({\n      methods: {\n        localePath: VueInstanceProxy(localePath),\n        localeRoute: VueInstanceProxy(localeRoute),\n        localeLocation: VueInstanceProxy(localeLocation),\n        switchLocalePath: VueInstanceProxy(switchLocalePath),\n        getRouteBaseName: VueInstanceProxy(getRouteBaseName)\n      }\n    })\n  }\n}\n\n/** @type {import('@nuxt/types').Plugin} */\nexport default (context) => {\n  Vue.use(plugin)\n  const { app, store } = context\n\n  app.localePath = context.localePath = NuxtContextProxy(context, localePath)\n  app.localeRoute = context.localeRoute = NuxtContextProxy(context, localeRoute)\n  app.localeLocation = context.localeLocation = NuxtContextProxy(context, localeLocation)\n  app.switchLocalePath = context.switchLocalePath = NuxtContextProxy(context, switchLocalePath)\n  app.getRouteBaseName = context.getRouteBaseName = NuxtContextProxy(context, getRouteBaseName)\n\n  if (store) {\n    store.localePath = app.localePath\n    store.localeRoute = app.localeRoute\n    store.localeLocation = app.localeLocation\n    store.switchLocalePath = app.switchLocalePath\n    store.getRouteBaseName = app.getRouteBaseName\n  }\n}\n","function set(obj, key, val) {\n\tif (typeof val.value === 'object') val.value = klona(val.value);\n\tif (!val.enumerable || val.get || val.set || !val.configurable || !val.writable || key === '__proto__') {\n\t\tObject.defineProperty(obj, key, val);\n\t} else obj[key] = val.value;\n}\n\nexport function klona(x) {\n\tif (typeof x !== 'object') return x;\n\n\tvar i=0, k, list, tmp, str=Object.prototype.toString.call(x);\n\n\tif (str === '[object Object]') {\n\t\ttmp = Object.create(x.__proto__ || null);\n\t} else if (str === '[object Array]') {\n\t\ttmp = Array(x.length);\n\t} else if (str === '[object Set]') {\n\t\ttmp = new Set;\n\t\tx.forEach(function (val) {\n\t\t\ttmp.add(klona(val));\n\t\t});\n\t} else if (str === '[object Map]') {\n\t\ttmp = new Map;\n\t\tx.forEach(function (val, key) {\n\t\t\ttmp.set(klona(key), klona(val));\n\t\t});\n\t} else if (str === '[object Date]') {\n\t\ttmp = new Date(+x);\n\t} else if (str === '[object RegExp]') {\n\t\ttmp = new RegExp(x.source, x.flags);\n\t} else if (str === '[object DataView]') {\n\t\ttmp = new x.constructor( klona(x.buffer) );\n\t} else if (str === '[object ArrayBuffer]') {\n\t\ttmp = x.slice(0);\n\t} else if (str.slice(-6) === 'Array]') {\n\t\t// ArrayBuffer.isView(x)\n\t\t// ~> `new` bcuz `Buffer.slice` => ref\n\t\ttmp = new x.constructor(x);\n\t}\n\n\tif (tmp) {\n\t\tfor (list=Object.getOwnPropertySymbols(x); i < list.length; i++) {\n\t\t\tset(tmp, list[i], Object.getOwnPropertyDescriptor(x, list[i]));\n\t\t}\n\n\t\tfor (i=0, list=Object.getOwnPropertyNames(x); i < list.length; i++) {\n\t\t\tif (Object.hasOwnProperty.call(tmp, k=list[i]) && tmp[k] === x[k]) continue;\n\t\t\tset(tmp, k, Object.getOwnPropertyDescriptor(x, k));\n\t\t}\n\t}\n\n\treturn tmp || x;\n}\n","import Vue from 'vue'\nimport VueI18n from 'vue-i18n'\nimport { isEqual as isURLEqual, joinURL } from '~i18n-ufo'\nimport { klona } from '~i18n-klona'\nimport { nuxtI18nHead } from './head-meta'\nimport { Constants, nuxtOptions, options } from './options'\nimport { createLocaleFromRouteGetter, getLocaleCookie, getLocaleDomain, getLocalesRegex, matchBrowserLocale, parseAcceptLanguage, setLocaleCookie } from './utils-common'\nimport { loadLanguageAsync, resolveBaseUrl, registerStore, mergeAdditionalMessages } from './plugin.utils'\n\nVue.use(VueI18n)\n\n/** @type {import('@nuxt/types').Plugin} */\nexport default async (context) => {\n  const { app, route, store, req, res, redirect } = context\n\n  if (options.vuex && store) {\n    registerStore(store, options.vuex, options.localeCodes)\n  }\n\n  const { lazy } = options\n  const injectInNuxtState = lazy && (lazy === true || lazy.skipNuxtState !== true)\n\n  if (process.server && injectInNuxtState) {\n    const devalue = (await import('devalue')).default\n    context.beforeNuxtRender(({ nuxtState }) => {\n      /** @type {Record<string, import('vue-i18n').LocaleMessageObject>} */\n      const langs = {}\n      const { fallbackLocale, locale } = app.i18n\n      if (locale && locale !== fallbackLocale) {\n        // @ts-ignore Using internal API to avoid unnecessary cloning.\n        const messages = app.i18n._getMessages()[locale]\n        if (messages) {\n          try {\n            devalue(messages)\n            langs[locale] = messages\n          } catch {\n            // Ignore - client-side will load the chunk asynchronously.\n          }\n        }\n      }\n      nuxtState.__i18n = { langs }\n    })\n  }\n\n  const {\n    alwaysRedirect,\n    fallbackLocale,\n    redirectOn,\n    useCookie,\n    cookieAge,\n    cookieKey,\n    cookieDomain,\n    cookieSecure,\n    cookieCrossOrigin\n  } = /** @type {Required<import('../../types').DetectBrowserLanguageOptions>} */(options.detectBrowserLanguage)\n\n  const getLocaleFromRoute = createLocaleFromRouteGetter(options.localeCodes, {\n    routesNameSeparator: options.routesNameSeparator,\n    defaultLocaleRouteNameSuffix: options.defaultLocaleRouteNameSuffix\n  })\n\n  /**\n   * @param {string | undefined} newLocale\n   * @param {{ initialSetup?: boolean }} [options=false]\n   */\n  const loadAndSetLocale = async (newLocale, { initialSetup = false } = {}) => {\n    if (!newLocale) {\n      return\n    }\n\n    // Abort if different domains option enabled\n    if (!initialSetup && app.i18n.differentDomains) {\n      return\n    }\n\n    const oldLocale = app.i18n.locale\n\n    if (newLocale === oldLocale) {\n      return\n    }\n\n    const localeOverride = app.i18n.onBeforeLanguageSwitch(oldLocale, newLocale, initialSetup, context)\n    if (localeOverride && app.i18n.localeCodes.includes(localeOverride)) {\n      if (localeOverride === oldLocale) {\n        return\n      }\n      newLocale = localeOverride\n    }\n\n    if (useCookie) {\n      app.i18n.setLocaleCookie(newLocale)\n    }\n\n    if (options.langDir) {\n      const i18nFallbackLocale = app.i18n.fallbackLocale\n\n      if (options.lazy) {\n        // Load fallback locale(s).\n        if (i18nFallbackLocale) {\n        /** @type {Promise<void>[]} */\n          let localesToLoadPromises = []\n          if (Array.isArray(i18nFallbackLocale)) {\n            localesToLoadPromises = i18nFallbackLocale.map(fbLocale => loadLanguageAsync(context, fbLocale))\n          } else if (typeof i18nFallbackLocale === 'object') {\n            if (i18nFallbackLocale[newLocale]) {\n              localesToLoadPromises = localesToLoadPromises.concat(i18nFallbackLocale[newLocale].map(fbLocale => loadLanguageAsync(context, fbLocale)))\n            }\n            if (i18nFallbackLocale.default) {\n              localesToLoadPromises = localesToLoadPromises.concat(i18nFallbackLocale.default.map(fbLocale => loadLanguageAsync(context, fbLocale)))\n            }\n          } else if (newLocale !== i18nFallbackLocale) {\n            localesToLoadPromises.push(loadLanguageAsync(context, i18nFallbackLocale))\n          }\n          await Promise.all(localesToLoadPromises)\n        }\n        await loadLanguageAsync(context, newLocale)\n      } else {\n        // Load all locales.\n        await Promise.all(options.localeCodes.map(locale => loadLanguageAsync(context, locale)))\n      }\n    } else {\n      mergeAdditionalMessages(app.i18n, options.additionalMessages, options.localeCodes)\n    }\n\n    app.i18n.locale = newLocale\n    /** @type {import('../../types').LocaleObject} */\n    const newLocaleProperties = options.normalizedLocales.find(l => l.code === newLocale) || { code: newLocale }\n    // In case certain locale has more properties than another, reset all the properties.\n    for (const key of Object.keys(app.i18n.localeProperties)) {\n      app.i18n.localeProperties[key] = undefined\n    }\n    // Copy properties of the new locale\n    for (const [key, value] of Object.entries(newLocaleProperties)) {\n      Vue.set(app.i18n.localeProperties, key, klona(value))\n    }\n\n    // Must retrieve from context as it might have changed since plugin initialization.\n    const { route } = context\n    let redirectPath = ''\n\n    const isStaticGenerate = process.static && process.server\n    // Decide whether we should redirect to a different route.\n    if (\n      !isStaticGenerate &&\n      !app.i18n.differentDomains &&\n      options.strategy !== Constants.STRATEGIES.NO_PREFIX &&\n      // Skip if already on the new locale unless the strategy is \"prefix_and_default\" and this is the default\n      // locale, in which case we might still redirect as we prefer unprefixed route in this case.\n      (getLocaleFromRoute(route) !== newLocale || (options.strategy === Constants.STRATEGIES.PREFIX_AND_DEFAULT && newLocale === options.defaultLocale))\n    ) {\n      // The current route could be 404 in which case attempt to find matching route using the full path since\n      // \"switchLocalePath\" can only find routes if the current route exists.\n      const routePath = app.switchLocalePath(newLocale) || app.localePath(route.fullPath, newLocale)\n      if (routePath && !isURLEqual(routePath, route.fullPath) && !routePath.startsWith('//')) {\n        redirectPath = routePath\n      }\n    }\n\n    if (initialSetup) {\n      // Redirect will be delayed until middleware runs as redirecting from plugin does not\n      // work in SPA (https://github.com/nuxt/nuxt.js/issues/4491).\n      app.i18n.__redirect = redirectPath\n    } else {\n      app.i18n.onLanguageSwitched(oldLocale, newLocale)\n\n      if (redirectPath) {\n        redirect(redirectPath)\n      }\n    }\n  }\n\n  /**\n   * Called by middleware on navigation (also on the initial one).\n   *\n   * @type {import('../../types/internal').onNavigateInternal}\n   */\n  const onNavigate = async route => {\n    // Handle root path redirect\n    if (route.path === '/' && options.rootRedirect) {\n      let statusCode = 302\n      let path = options.rootRedirect\n\n      if (typeof options.rootRedirect !== 'string') {\n        statusCode = options.rootRedirect.statusCode\n        path = options.rootRedirect.path\n      }\n\n      return [statusCode, `/${path}`, /* preserve query */true]\n    }\n\n    const storedRedirect = app.i18n.__redirect\n    if (storedRedirect) {\n      app.i18n.__redirect = null\n      return [302, storedRedirect]\n    }\n\n    const resolveBaseUrlOptions = {\n      differentDomains: options.differentDomains,\n      normalizedLocales: options.normalizedLocales\n    }\n    app.i18n.__baseUrl = resolveBaseUrl(options.baseUrl, context, app.i18n.locale, resolveBaseUrlOptions)\n\n    const finalLocale =\n      (options.detectBrowserLanguage && doDetectBrowserLanguage(route)) ||\n      (!options.differentDomains && options.strategy !== Constants.STRATEGIES.NO_PREFIX && getLocaleFromRoute(route)) ||\n      app.i18n.locale || app.i18n.defaultLocale || ''\n\n    if (options.skipSettingLocaleOnNavigate) {\n      app.i18n.__pendingLocale = finalLocale\n      app.i18n.__pendingLocalePromise = new Promise(resolve => {\n        app.i18n.__resolvePendingLocalePromise = resolve\n      })\n    } else {\n      await app.i18n.setLocale(finalLocale)\n    }\n\n    return [null, null]\n  }\n\n  const finalizePendingLocaleChange = async () => {\n    if (!app.i18n.__pendingLocale) {\n      return\n    }\n    await app.i18n.setLocale(app.i18n.__pendingLocale)\n    app.i18n.__resolvePendingLocalePromise('')\n    app.i18n.__pendingLocale = null\n  }\n\n  const waitForPendingLocaleChange = async () => {\n    if (app.i18n.__pendingLocale) {\n      await app.i18n.__pendingLocalePromise\n    }\n  }\n\n  const getBrowserLocale = () => {\n    if (process.client && typeof navigator !== 'undefined' && navigator.languages) {\n      // Get browser language either from navigator if running on client side, or from the headers\n      return matchBrowserLocale(options.normalizedLocales, navigator.languages)\n    } else if (req && typeof req.headers['accept-language'] !== 'undefined') {\n      return matchBrowserLocale(options.normalizedLocales, parseAcceptLanguage(req.headers['accept-language']))\n    } else {\n      return undefined\n    }\n  }\n\n  /**\n   * @param {import('vue-router').Route} route\n   * @return {string} Returns the browser locale that was detected or an empty string otherwise.\n   */\n  const doDetectBrowserLanguage = route => {\n    // Browser detection is ignored if it is a nuxt generate.\n    if (process.static && process.server) {\n      return ''\n    }\n\n    if (options.strategy !== Constants.STRATEGIES.NO_PREFIX) {\n      if (redirectOn === Constants.REDIRECT_ON_OPTIONS.ROOT) {\n        if (route.path !== '/') {\n          return ''\n        }\n      } else if (redirectOn === Constants.REDIRECT_ON_OPTIONS.NO_PREFIX) {\n        if (!alwaysRedirect && route.path.match(getLocalesRegex(options.localeCodes))) {\n          return ''\n        }\n      }\n    }\n\n    let matchedLocale\n\n    if (useCookie && (matchedLocale = app.i18n.getLocaleCookie())) {\n      // Get preferred language from cookie if present and enabled\n    } else {\n      // Try to get locale from either navigator or header detection\n      matchedLocale = getBrowserLocale()\n    }\n\n    const finalLocale = matchedLocale || fallbackLocale\n\n    // Handle cookie option to prevent multiple redirections\n    if (finalLocale && (!useCookie || alwaysRedirect || !app.i18n.getLocaleCookie())) {\n      if (finalLocale !== app.i18n.locale) {\n        return finalLocale\n      }\n    }\n\n    return ''\n  }\n\n  /**\n   * Extends the newly created vue-i18n instance with @nuxtjs/i18n properties.\n   *\n   * @param {import('vue-i18n').IVueI18n} i18n\n   */\n  const extendVueI18nInstance = i18n => {\n    i18n.locales = klona(options.locales)\n    i18n.localeCodes = klona(options.localeCodes)\n    i18n.localeProperties = Vue.observable(klona(options.normalizedLocales.find(l => l.code === i18n.locale) || { code: i18n.locale }))\n    i18n.defaultLocale = options.defaultLocale\n    i18n.differentDomains = options.differentDomains\n    i18n.onBeforeLanguageSwitch = options.onBeforeLanguageSwitch\n    i18n.onLanguageSwitched = options.onLanguageSwitched\n    i18n.setLocaleCookie = locale => setLocaleCookie(locale, res, { useCookie, cookieAge, cookieDomain, cookieKey, cookieSecure, cookieCrossOrigin })\n    i18n.getLocaleCookie = () => getLocaleCookie(req, { useCookie, cookieKey, localeCodes: options.localeCodes })\n    i18n.setLocale = (locale) => loadAndSetLocale(locale)\n    i18n.getBrowserLocale = () => getBrowserLocale()\n    i18n.finalizePendingLocaleChange = finalizePendingLocaleChange\n    i18n.waitForPendingLocaleChange = waitForPendingLocaleChange\n    i18n.__baseUrl = app.i18n.__baseUrl\n    i18n.__pendingLocale = app.i18n.__pendingLocale\n    i18n.__pendingLocalePromise = app.i18n.__pendingLocalePromise\n    i18n.__resolvePendingLocalePromise = app.i18n.__resolvePendingLocalePromise\n  }\n\n  // Set instance options\n  const vueI18nOptions = typeof options.vueI18n === 'function' ? await options.vueI18n(context) : klona(options.vueI18n)\n  vueI18nOptions.componentInstanceCreatedListener = extendVueI18nInstance\n  // @ts-ignore\n  app.i18n = context.i18n = new VueI18n(vueI18nOptions)\n  // Initialize locale and fallbackLocale as vue-i18n defaults those to 'en-US' if falsey\n  app.i18n.locale = ''\n  app.i18n.fallbackLocale = vueI18nOptions.fallbackLocale || ''\n\n  if (store) {\n    // Inject in store.\n    store.$i18n = app.i18n\n\n    if (store.state.localeDomains) {\n      for (const [index, locale] of options.normalizedLocales.entries()) {\n        const domain = store.state.localeDomains[locale.code]\n        if (domain) {\n          locale.domain = domain\n          const optionsLocale = options.locales[index]\n          if (typeof (optionsLocale) !== 'string') {\n            optionsLocale.domain = domain\n          }\n        }\n      }\n    }\n  }\n\n  extendVueI18nInstance(app.i18n)\n  const resolveBaseUrlOptions = {\n    differentDomains: options.differentDomains,\n    normalizedLocales: options.normalizedLocales\n  }\n  app.i18n.__baseUrl = resolveBaseUrl(options.baseUrl, context, '', resolveBaseUrlOptions)\n  app.i18n.__onNavigate = onNavigate\n\n  Vue.prototype.$nuxtI18nHead = nuxtI18nHead\n\n  /** @type {string | undefined} */\n  let finalLocale = options.detectBrowserLanguage ? doDetectBrowserLanguage(route) : ''\n\n  if (!finalLocale) {\n    if (app.i18n.differentDomains) {\n      const domainLocale = getLocaleDomain(options.normalizedLocales, req)\n      finalLocale = domainLocale\n    } else if (options.strategy !== Constants.STRATEGIES.NO_PREFIX) {\n      const routeLocale = getLocaleFromRoute(route)\n      finalLocale = routeLocale\n    }\n  }\n\n  if (!finalLocale && useCookie) {\n    finalLocale = app.i18n.getLocaleCookie()\n  }\n\n  if (!finalLocale) {\n    finalLocale = app.i18n.defaultLocale || ''\n  }\n\n  await loadAndSetLocale(finalLocale, { initialSetup: true })\n\n  if (process.client && process.static && nuxtOptions.isUniversalMode) {\n    const [_, redirectTo] = await onNavigate(context.route)\n    if (redirectTo) {\n      location.assign(joinURL(context.base, redirectTo))\n    }\n  }\n}\n","import Axios from 'axios'\nimport defu from 'defu'\n\n// Axios.prototype cannot be modified\nconst axiosExtra = {\n  setBaseURL (baseURL) {\n    this.defaults.baseURL = baseURL\n  },\n  setHeader (name, value, scopes = 'common') {\n    for (const scope of Array.isArray(scopes) ? scopes : [ scopes ]) {\n      if (!value) {\n        delete this.defaults.headers[scope][name];\n        continue\n      }\n      this.defaults.headers[scope][name] = value\n    }\n  },\n  setToken (token, type, scopes = 'common') {\n    const value = !token ? null : (type ? type + ' ' : '') + token\n    this.setHeader('Authorization', value, scopes)\n  },\n  onRequest(fn) {\n    this.interceptors.request.use(config => fn(config) || config)\n  },\n  onResponse(fn) {\n    this.interceptors.response.use(response => fn(response) || response)\n  },\n  onRequestError(fn) {\n    this.interceptors.request.use(undefined, error => fn(error) || Promise.reject(error))\n  },\n  onResponseError(fn) {\n    this.interceptors.response.use(undefined, error => fn(error) || Promise.reject(error))\n  },\n  onError(fn) {\n    this.onRequestError(fn)\n    this.onResponseError(fn)\n  },\n  create(options) {\n    return createAxiosInstance(defu(options, this.defaults))\n  }\n}\n\n// Request helpers ($get, $post, ...)\nfor (const method of ['request', 'delete', 'get', 'head', 'options', 'post', 'put', 'patch']) {\n  axiosExtra['$' + method] = function () { return this[method].apply(this, arguments).then(res => res && res.data) }\n}\n\nconst extendAxiosInstance = axios => {\n  for (const key in axiosExtra) {\n    axios[key] = axiosExtra[key].bind(axios)\n  }\n}\n\nconst createAxiosInstance = axiosOptions => {\n  // Create new axios instance\n  const axios = Axios.create(axiosOptions)\n  axios.CancelToken = Axios.CancelToken\n  axios.isCancel = Axios.isCancel\n\n  // Extend axios proto\n  extendAxiosInstance(axios)\n\n  // Intercept to apply default headers\n  axios.onRequest((config) => {\n    config.headers = { ...axios.defaults.headers.common, ...config.headers }\n  })\n\n  // Setup interceptors\n\n  setupProgress(axios)\n\n  return axios\n}\n\nconst setupProgress = (axios) => {\n  if (process.server) {\n    return\n  }\n\n  // A noop loading inteterface for when $nuxt is not yet ready\n  const noopLoading = {\n    finish: () => { },\n    start: () => { },\n    fail: () => { },\n    set: () => { }\n  }\n\n  const $loading = () => {\n    const $nuxt = typeof window !== 'undefined' && window['$nuxt']\n    return ($nuxt && $nuxt.$loading && $nuxt.$loading.set) ? $nuxt.$loading : noopLoading\n  }\n\n  let currentRequests = 0\n\n  axios.onRequest(config => {\n    if (config && config.progress === false) {\n      return\n    }\n\n    currentRequests++\n  })\n\n  axios.onResponse(response => {\n    if (response && response.config && response.config.progress === false) {\n      return\n    }\n\n    currentRequests--\n    if (currentRequests <= 0) {\n      currentRequests = 0\n      $loading().finish()\n    }\n  })\n\n  axios.onError(error => {\n    if (error && error.config && error.config.progress === false) {\n      return\n    }\n\n    currentRequests--\n\n    if (Axios.isCancel(error)) {\n      if (currentRequests <= 0) {\n        currentRequests = 0\n        $loading().finish()\n      }\n      return\n    }\n\n    $loading().fail()\n    $loading().finish()\n  })\n\n  const onProgress = e => {\n    if (!currentRequests || !e.total) {\n      return\n    }\n    const progress = ((e.loaded * 100) / (e.total * currentRequests))\n    $loading().set(Math.min(100, progress))\n  }\n\n  axios.defaults.onUploadProgress = onProgress\n  axios.defaults.onDownloadProgress = onProgress\n}\n\nexport default (ctx, inject) => {\n  // runtimeConfig\n  const runtimeConfig = ctx.$config && ctx.$config.axios || {}\n  // baseURL\n  const baseURL = process.browser\n    ? (runtimeConfig.browserBaseURL || runtimeConfig.browserBaseUrl || runtimeConfig.baseURL || runtimeConfig.baseUrl || '/')\n      : (runtimeConfig.baseURL || runtimeConfig.baseUrl || process.env._AXIOS_BASE_URL_ || '/')\n\n  // Create fresh objects for all default header scopes\n  // Axios creates only one which is shared across SSR requests!\n  // https://github.com/mzabriskie/axios/blob/master/lib/defaults.js\n  const headers = {\n    \"common\": {\n        \"Accept\": \"application/json, text/plain, */*\"\n    },\n    \"delete\": {},\n    \"get\": {},\n    \"head\": {},\n    \"post\": {},\n    \"put\": {},\n    \"patch\": {}\n}\n\n  const axiosOptions = {\n    baseURL,\n    headers\n  }\n\n  // Proxy SSR request headers headers\n  if (process.server && ctx.req && ctx.req.headers) {\n    const reqHeaders = { ...ctx.req.headers }\n    for (const h of [\"accept\",\"cf-connecting-ip\",\"cf-ray\",\"content-length\",\"content-md5\",\"content-type\",\"host\",\"x-forwarded-host\",\"x-forwarded-port\",\"x-forwarded-proto\"]) {\n      delete reqHeaders[h]\n    }\n    axiosOptions.headers.common = { ...reqHeaders, ...axiosOptions.headers.common }\n  }\n\n  if (process.server) {\n    // Don't accept brotli encoding because Node can't parse it\n    axiosOptions.headers.common['accept-encoding'] = 'gzip, deflate'\n  }\n\n  const axios = createAxiosInstance(axiosOptions)\n\n  // Inject axios to the context as $axios\n  ctx.$axios = axios\n  inject('axios', axios)\n}\n","export async function imageMeta(ctx, url) {\n  const cache = getCache(ctx);\n  const cacheKey = \"image:meta:\" + url;\n  if (cache.has(cacheKey)) {\n    return cache.get(cacheKey);\n  }\n  const meta = await _imageMeta(url).catch((err) => {\n    console.error(\"Failed to get image meta for \" + url, err + \"\");\n    return {\n      width: 0,\n      height: 0,\n      ratio: 0\n    };\n  });\n  cache.set(cacheKey, meta);\n  return meta;\n}\nasync function _imageMeta(url) {\n  if (process.server) {\n    const imageMeta2 = await import(\"image-meta\").then((r) => r.default || r);\n    const data = await fetch(url).then((res) => res.buffer());\n    const metadata = imageMeta2(data);\n    if (!metadata) {\n      throw new Error(`No metadata could be extracted from the image \\`${url}\\`.`);\n    }\n    const { width, height } = metadata;\n    const meta = {\n      width,\n      height,\n      ratio: width && height ? width / height : void 0\n    };\n    return meta;\n  }\n  if (typeof Image === \"undefined\") {\n    throw new TypeError(\"Image not supported\");\n  }\n  return new Promise((resolve, reject) => {\n    const img = new Image();\n    img.onload = () => {\n      const meta = {\n        width: img.width,\n        height: img.height,\n        ratio: img.width / img.height\n      };\n      resolve(meta);\n    };\n    img.onerror = (err) => reject(err);\n    img.src = url;\n  });\n}\nfunction getCache(ctx) {\n  if (!ctx.nuxtContext.cache) {\n    if (ctx.nuxtContext.ssrContext && ctx.nuxtContext.ssrContext.cache) {\n      ctx.nuxtContext.cache = ctx.nuxtContext.ssrContext.cache;\n    } else {\n      const _cache = {};\n      ctx.nuxtContext.cache = {\n        get: (id) => _cache[id],\n        set: (id, value) => {\n          _cache[id] = value;\n        },\n        has: (id) => typeof _cache[id] !== \"undefined\"\n      };\n    }\n  }\n  return ctx.nuxtContext.cache;\n}\n","export default function imageFetch(url) {\n  return fetch(cleanDoubleSlashes(url));\n}\nexport function getInt(x) {\n  if (typeof x === \"number\") {\n    return x;\n  }\n  if (typeof x === \"string\") {\n    return parseInt(x, 10);\n  }\n  return void 0;\n}\nexport function getFileExtension(url = \"\") {\n  const extension = url.split(/[?#]/).shift().split(\"/\").pop().split(\".\").pop();\n  return extension;\n}\nexport function cleanDoubleSlashes(path = \"\") {\n  return path.replace(/(https?:\\/\\/)|(\\/)+/g, \"$1$2\");\n}\nexport function createMapper(map) {\n  return (key) => {\n    return key ? map[key] || key : map.missingValue;\n  };\n}\nexport function createOperationsGenerator({ formatter, keyMap, joinWith = \"/\", valueMap } = {}) {\n  if (!formatter) {\n    formatter = (key, value) => `${key}=${value}`;\n  }\n  if (keyMap && typeof keyMap !== \"function\") {\n    keyMap = createMapper(keyMap);\n  }\n  const map = valueMap || {};\n  Object.keys(map).forEach((valueKey) => {\n    if (typeof map[valueKey] !== \"function\") {\n      map[valueKey] = createMapper(map[valueKey]);\n    }\n  });\n  return (modifiers = {}) => {\n    const operations = Object.entries(modifiers).filter(([_, value]) => typeof value !== \"undefined\").map(([key, value]) => {\n      const mapper = map[key];\n      if (typeof mapper === \"function\") {\n        value = mapper(modifiers[key]);\n      }\n      key = typeof keyMap === \"function\" ? keyMap(key) : key;\n      return formatter(key, value);\n    });\n    return operations.join(joinWith);\n  };\n}\nexport function renderAttributesToString(attributes = {}) {\n  return Object.entries(attributes).map(([key, value]) => value ? `${key}=\"${value}\"` : \"\").filter(Boolean).join(\" \");\n}\nexport function renderTag(tag, attrs, contents) {\n  const html = `<${tag} ${renderAttributesToString(attrs)}>`;\n  if (!contents) {\n    return html;\n  }\n  return html + contents + `</${tag}>`;\n}\nexport function generateAlt(src = \"\") {\n  return src.split(/[?#]/).shift().split(\"/\").pop().split(\".\").shift();\n}\nexport function parseSize(input = \"\") {\n  if (typeof input === \"number\") {\n    return input;\n  }\n  if (typeof input === \"string\") {\n    if (input.replace(\"px\", \"\").match(/^\\d+$/g)) {\n      return parseInt(input, 10);\n    }\n  }\n}\n","import defu from \"defu\";\nimport { hasProtocol, parseURL, joinURL, withLeadingSlash } from \"ufo\";\nimport { imageMeta } from \"./utils/meta\";\nimport { parseSize } from \"./utils\";\nimport { useStaticImageMap } from \"./utils/static-map\";\nexport function createImage(globalOptions, nuxtContext) {\n  const staticImageManifest = process.client && process.static ? useStaticImageMap(nuxtContext) : {};\n  const ctx = {\n    options: globalOptions,\n    nuxtContext\n  };\n  const getImage = function(input, options = {}) {\n    const image = resolveImage(ctx, input, options);\n    if (image.isStatic) {\n      handleStaticImage(image, input);\n    }\n    return image;\n  };\n  const $img = function $img2(input, modifiers = {}, options = {}) {\n    return getImage(input, {\n      ...options,\n      modifiers: defu(modifiers, options.modifiers || {})\n    }).url;\n  };\n  function handleStaticImage(image, input) {\n    if (process.static) {\n      if (process.client && \"fetchPayload\" in window.$nuxt) {\n        const mappedURL = staticImageManifest[image.url];\n        image.url = mappedURL || input;\n        return image;\n      }\n      if (process.server) {\n        const { ssrContext } = ctx.nuxtContext;\n        if (ssrContext) {\n          const ssrState = ssrContext.nuxt || {};\n          const staticImages = ssrState._img = ssrState._img || {};\n          const ssrData = ssrState.data?.[0];\n          if (ssrData) {\n            ssrData._img = staticImages;\n          }\n          const mapToStatic = ssrContext.image?.mapToStatic;\n          if (typeof mapToStatic === \"function\") {\n            const mappedURL = mapToStatic(image, input);\n            if (mappedURL) {\n              staticImages[image.url] = mappedURL;\n              image.url = mappedURL;\n            }\n          }\n        }\n      }\n    } else if (process.env.NODE_ENV === \"production\") {\n      image.url = input;\n    }\n  }\n  for (const presetName in globalOptions.presets) {\n    $img[presetName] = (source, modifiers, options) => $img(source, modifiers, { ...globalOptions.presets[presetName], ...options });\n  }\n  $img.options = globalOptions;\n  $img.getImage = getImage;\n  $img.getMeta = (input, options) => getMeta(ctx, input, options);\n  $img.getSizes = (input, options) => getSizes(ctx, input, options);\n  ctx.$img = $img;\n  return $img;\n}\nasync function getMeta(ctx, input, options) {\n  const image = resolveImage(ctx, input, { ...options });\n  if (typeof image.getMeta === \"function\") {\n    return await image.getMeta();\n  } else {\n    return await imageMeta(ctx, image.url);\n  }\n}\nfunction resolveImage(ctx, input, options) {\n  if (typeof input !== \"string\" || input === \"\") {\n    throw new TypeError(`input must be a string (received ${typeof input}: ${JSON.stringify(input)})`);\n  }\n  if (input.startsWith(\"data:\")) {\n    return {\n      url: input\n    };\n  }\n  const { provider, defaults } = getProvider(ctx, options.provider || ctx.options.provider);\n  const preset = getPreset(ctx, options.preset);\n  input = hasProtocol(input) ? input : withLeadingSlash(input);\n  if (!provider.supportsAlias) {\n    for (const base in ctx.options.alias) {\n      if (input.startsWith(base)) {\n        input = joinURL(ctx.options.alias[base], input.substr(base.length));\n      }\n    }\n  }\n  if (provider.validateDomains && hasProtocol(input)) {\n    const inputHost = parseURL(input).host;\n    if (!ctx.options.domains.find((d) => d === inputHost)) {\n      return {\n        url: input\n      };\n    }\n  }\n  const _options = defu(options, preset, defaults);\n  _options.modifiers = { ..._options.modifiers };\n  const expectedFormat = _options.modifiers.format;\n  if (_options.modifiers?.width) {\n    _options.modifiers.width = parseSize(_options.modifiers.width);\n  }\n  if (_options.modifiers?.height) {\n    _options.modifiers.height = parseSize(_options.modifiers.height);\n  }\n  const image = provider.getImage(input, _options, ctx);\n  image.format = image.format || expectedFormat || \"\";\n  return image;\n}\nfunction getProvider(ctx, name) {\n  const provider = ctx.options.providers[name];\n  if (!provider) {\n    throw new Error(\"Unknown provider: \" + name);\n  }\n  return provider;\n}\nfunction getPreset(ctx, name) {\n  if (!name) {\n    return {};\n  }\n  if (!ctx.options.presets[name]) {\n    throw new Error(\"Unknown preset: \" + name);\n  }\n  return ctx.options.presets[name];\n}\nfunction getSizes(ctx, input, opts) {\n  const width = parseSize(opts.modifiers?.width);\n  const height = parseSize(opts.modifiers?.height);\n  const hwRatio = width && height ? height / width : 0;\n  const variants = [];\n  const sizes = {};\n  if (typeof opts.sizes === \"string\") {\n    for (const entry of opts.sizes.split(/[\\s,]+/).filter((e) => e)) {\n      const s = entry.split(\":\");\n      if (s.length !== 2) {\n        continue;\n      }\n      sizes[s[0].trim()] = s[1].trim();\n    }\n  } else {\n    Object.assign(sizes, opts.sizes);\n  }\n  for (const key in sizes) {\n    const screenMaxWidth = ctx.options.screens && ctx.options.screens[key] || parseInt(key);\n    let size = String(sizes[key]);\n    const isFluid = size.endsWith(\"vw\");\n    if (!isFluid && /^\\d+$/.test(size)) {\n      size = size + \"px\";\n    }\n    if (!isFluid && !size.endsWith(\"px\")) {\n      continue;\n    }\n    let _cWidth = parseInt(size);\n    if (!screenMaxWidth || !_cWidth) {\n      continue;\n    }\n    if (isFluid) {\n      _cWidth = Math.round(_cWidth / 100 * screenMaxWidth);\n    }\n    const _cHeight = hwRatio ? Math.round(_cWidth * hwRatio) : height;\n    variants.push({\n      width: _cWidth,\n      size,\n      screenMaxWidth,\n      media: `(max-width: ${screenMaxWidth}px)`,\n      src: ctx.$img(input, { ...opts.modifiers, width: _cWidth, height: _cHeight }, opts)\n    });\n  }\n  variants.sort((v1, v2) => v1.screenMaxWidth - v2.screenMaxWidth);\n  const defaultVar = variants[variants.length - 1];\n  if (defaultVar) {\n    defaultVar.media = \"\";\n  }\n  return {\n    sizes: variants.map((v) => `${v.media ? v.media + \" \" : \"\"}${v.size}`).join(\", \"),\n    srcset: variants.map((v) => `${v.src} ${v.width}w`).join(\", \"),\n    src: defaultVar?.src\n  };\n}\n","var render = function render(){var _vm=this,_c=_vm._self._c,_setup=_vm._self._setupProxy;return _c('img',_vm._g(_vm._b({key:_vm.nSrc,ref:\"img\",attrs:{\"src\":_vm.nSrc}},'img',_vm.nAttrs,false),_vm.$listeners),[])\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","import { parseSize } from \"../utils\";\nconst defineMixin = (opts) => opts;\nexport const imageMixin = defineMixin({\n  props: {\n    src: { type: String, required: true },\n    format: { type: String, default: void 0 },\n    quality: { type: [Number, String], default: void 0 },\n    background: { type: String, default: void 0 },\n    fit: { type: String, default: void 0 },\n    modifiers: { type: Object, default: void 0 },\n    preset: { type: String, default: void 0 },\n    provider: { type: String, default: void 0 },\n    sizes: { type: [Object, String], default: void 0 },\n    preload: { type: Boolean, default: void 0 },\n    width: { type: [String, Number], default: void 0 },\n    height: { type: [String, Number], default: void 0 },\n    alt: { type: String, default: void 0 },\n    referrerpolicy: { type: String, default: void 0 },\n    usemap: { type: String, default: void 0 },\n    longdesc: { type: String, default: void 0 },\n    ismap: { type: Boolean, default: void 0 },\n    crossorigin: { type: [Boolean, String], default: void 0, validator: (val) => [\"anonymous\", \"use-credentials\", \"\", true, false].includes(val) },\n    loading: { type: String, default: void 0 },\n    decoding: { type: String, default: void 0, validator: (val) => [\"async\", \"auto\", \"sync\"].includes(val) }\n  },\n  computed: {\n    nImgAttrs() {\n      return {\n        width: parseSize(this.width),\n        height: parseSize(this.height),\n        alt: this.alt,\n        referrerpolicy: this.referrerpolicy,\n        usemap: this.usemap,\n        longdesc: this.longdesc,\n        ismap: this.ismap,\n        crossorigin: this.crossorigin === true ? \"anonymous\" : this.crossorigin || void 0,\n        loading: this.loading,\n        decoding: this.decoding\n      };\n    },\n    nModifiers() {\n      return {\n        ...this.modifiers,\n        width: parseSize(this.width),\n        height: parseSize(this.height),\n        format: this.format,\n        quality: this.quality,\n        background: this.background,\n        fit: this.fit\n      };\n    },\n    nOptions() {\n      return {\n        provider: this.provider,\n        preset: this.preset\n      };\n    }\n  }\n});\n","import mod from \"-!../../../../../babel-loader/lib/index.js??ref--2-0!../../../../components/dist/loader.js??ref--0-0!../../../../../vue-loader/lib/index.js??vue-loader-options!./nuxt-img.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../../../babel-loader/lib/index.js??ref--2-0!../../../../components/dist/loader.js??ref--0-0!../../../../../vue-loader/lib/index.js??vue-loader-options!./nuxt-img.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./nuxt-img.vue?vue&type=template&id=4c03b41d&\"\nimport script from \"./nuxt-img.vue?vue&type=script&lang=js&\"\nexport * from \"./nuxt-img.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../../vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  \"6d872193\"\n  \n)\n\nexport default component.exports","var render = function render(){var _vm=this,_c=_vm._self._c,_setup=_vm._self._setupProxy;return _c('picture',{key:_vm.nSources[0].src},[_vm._ssrNode(((_vm.nSources[1])?(\"<source\"+(_vm._ssrAttr(\"type\",_vm.nSources[1].type))+(_vm._ssrAttr(\"srcset\",_vm.nSources[1].srcset))+(_vm._ssrAttr(\"sizes\",_vm.nSources[1].sizes))+\">\"):\"<!---->\")+\" <img\"+(_vm._ssrAttr(\"src\",_vm.nSources[0].src))+(_vm._ssrAttr(\"srcset\",_vm.nSources[0].srcset))+(_vm._ssrAttr(\"sizes\",_vm.nSources[0].sizes))+(_vm._ssrAttrs({..._vm.nImgAttrs, ..._vm.imgAttrs}))+\">\")])\n}\nvar staticRenderFns = []\n\nexport { render, staticRenderFns }","import mod from \"-!../../../../../babel-loader/lib/index.js??ref--2-0!../../../../components/dist/loader.js??ref--0-0!../../../../../vue-loader/lib/index.js??vue-loader-options!./nuxt-picture.vue?vue&type=script&lang=js&\"; export default mod; export * from \"-!../../../../../babel-loader/lib/index.js??ref--2-0!../../../../components/dist/loader.js??ref--0-0!../../../../../vue-loader/lib/index.js??vue-loader-options!./nuxt-picture.vue?vue&type=script&lang=js&\"","import { render, staticRenderFns } from \"./nuxt-picture.vue?vue&type=template&id=310bdcc2&\"\nimport script from \"./nuxt-picture.vue?vue&type=script&lang=js&\"\nexport * from \"./nuxt-picture.vue?vue&type=script&lang=js&\"\n\n\n/* normalize component */\nimport normalizer from \"!../../../../../vue-loader/lib/runtime/componentNormalizer.js\"\nvar component = normalizer(\n  script,\n  render,\n  staticRenderFns,\n  false,\n  null,\n  null,\n  \"48d3b54e\"\n  \n)\n\nexport default component.exports","import { joinURL, encodePath, encodeParam } from \"ufo\";\nimport { createOperationsGenerator } from \"~image\";\nconst operationsGenerator = createOperationsGenerator({\n  keyMap: {\n    format: \"f\",\n    fit: \"fit\",\n    width: \"w\",\n    height: \"h\",\n    resize: \"s\",\n    quality: \"q\",\n    background: \"b\"\n  },\n  joinWith: \",\",\n  formatter: (key, val) => encodeParam(key) + \"_\" + encodeParam(val)\n});\nexport const getImage = (src, { modifiers = {}, baseURL } = {}, ctx) => {\n  if (modifiers.width && modifiers.height) {\n    modifiers.resize = `${modifiers.width}x${modifiers.height}`;\n    delete modifiers.width;\n    delete modifiers.height;\n  }\n  const params = operationsGenerator(modifiers) || \"_\";\n  if (!baseURL) {\n    baseURL = joinURL(ctx.nuxtContext?.base || \"/\", \"/_ipx\");\n  }\n  return {\n    url: joinURL(baseURL, params, encodePath(src))\n  };\n};\nexport const validateDomains = true;\nexport const supportsAlias = true;\n","import { getImage as _getImage } from \"./ipx\";\nexport const getImage = (src, options, ctx) => ({\n  ..._getImage(src, options, ctx),\n  isStatic: true\n});\nexport const supportsAlias = true;\n","import Vue from 'vue'\nimport { createImage} from '~image'\nimport NuxtImg from '~image/components/nuxt-img.vue'\nimport NuxtPicture from '~image/components/nuxt-picture.vue'\n\nimport * as staticRuntime$1137 from 'C:/Users/houid/McnWork/Nuxt2Test/node_modules/@nuxt/image/dist/runtime/providers/static.js'\nimport * as ipxRuntime$f9c4 from 'C:/Users/houid/McnWork/Nuxt2Test/node_modules/@nuxt/image/dist/runtime/providers/ipx.js'\n\nconst imageOptions = {\n  \"screens\": {\n    \"xs\": 320,\n    \"sm\": 640,\n    \"md\": 768,\n    \"lg\": 1024,\n    \"xl\": 1280,\n    \"xxl\": 1536,\n    \"2xl\": 1536\n  },\n  \"presets\": {},\n  \"provider\": \"ipx\",\n  \"domains\": [],\n  \"alias\": {}\n}\n\nimageOptions.providers = {\n  ['static']: { provider: staticRuntime$1137, defaults: {} },\n  ['ipx']: { provider: ipxRuntime$f9c4, defaults: {} }\n}\n\nVue.component(NuxtImg.name, NuxtImg)\nVue.component(NuxtPicture.name, NuxtPicture)\nVue.component('NImg', NuxtImg)\nVue.component('NPicture', NuxtPicture)\n\nexport default function (nuxtContext, inject) {\n  const $img = createImage(imageOptions, nuxtContext)\n\n  if (process.static && process.server) {\n    nuxtContext.beforeNuxtRender(({ nuxtState }) => {\n      const ssrData = nuxtState.data[0] || {}\n      ssrData._img = nuxtState._img || {}\n    })\n  }\n\n  inject('img', $img)\n}\n","import Vue from 'vue'\n\nimport Meta from 'vue-meta'\nimport ClientOnly from 'vue-client-only'\nimport NoSsr from 'vue-no-ssr'\nimport { createRouter } from './router.js'\nimport NuxtChild from './components/nuxt-child.js'\nimport NuxtError from '..\\\\layouts\\\\error.vue'\nimport Nuxt from './components/nuxt.js'\nimport App from './App.js'\nimport { setContext, getLocation, getRouteData, normalizeError } from './utils'\n\n/* Plugins */\n\nimport nuxt_plugin_plugin_0f208ee6 from 'nuxt_plugin_plugin_0f208ee6' // Source: .\\\\components\\\\plugin.js (mode: 'all')\nimport nuxt_plugin_plugin_7416d2f2 from 'nuxt_plugin_plugin_7416d2f2' // Source: .\\\\vuetify\\\\plugin.js (mode: 'all')\nimport nuxt_plugin_pluginutils_828c0784 from 'nuxt_plugin_pluginutils_828c0784' // Source: .\\\\nuxt-i18n\\\\plugin.utils.js (mode: 'all')\nimport nuxt_plugin_pluginrouting_a3a71bee from 'nuxt_plugin_pluginrouting_a3a71bee' // Source: .\\\\nuxt-i18n\\\\plugin.routing.js (mode: 'all')\nimport nuxt_plugin_pluginmain_ac3843f4 from 'nuxt_plugin_pluginmain_ac3843f4' // Source: .\\\\nuxt-i18n\\\\plugin.main.js (mode: 'all')\nimport nuxt_plugin_axios_2675d830 from 'nuxt_plugin_axios_2675d830' // Source: .\\\\axios.js (mode: 'all')\nimport nuxt_plugin_image_117cd52b from 'nuxt_plugin_image_117cd52b' // Source: .\\\\image.js (mode: 'all')\n\n// Component: <ClientOnly>\nVue.component(ClientOnly.name, ClientOnly)\n\n// TODO: Remove in Nuxt 3: <NoSsr>\nVue.component(NoSsr.name, {\n  ...NoSsr,\n  render (h, ctx) {\n    if (process.client && !NoSsr._warned) {\n      NoSsr._warned = true\n\n      console.warn('<no-ssr> has been deprecated and will be removed in Nuxt 3, please use <client-only> instead')\n    }\n    return NoSsr.render(h, ctx)\n  }\n})\n\n// Component: <NuxtChild>\nVue.component(NuxtChild.name, NuxtChild)\nVue.component('NChild', NuxtChild)\n\n// Component NuxtLink is imported in server.js or client.js\n\n// Component: <Nuxt>\nVue.component(Nuxt.name, Nuxt)\n\nObject.defineProperty(Vue.prototype, '$nuxt', {\n  get() {\n    const globalNuxt = this.$root ? this.$root.$options.$nuxt : null\n    if (process.client && !globalNuxt && typeof window !== 'undefined') {\n      return window.$nuxt\n    }\n    return globalNuxt\n  },\n  configurable: true\n})\n\nVue.use(Meta, {\"keyName\":\"head\",\"attribute\":\"data-n-head\",\"ssrAttribute\":\"data-n-head-ssr\",\"tagIDKeyName\":\"hid\"})\n\nconst defaultTransition = {\"name\":\"page\",\"mode\":\"out-in\",\"appear\":false,\"appearClass\":\"appear\",\"appearActiveClass\":\"appear-active\",\"appearToClass\":\"appear-to\"}\n\nasync function createApp(ssrContext, config = {}) {\n  const store = null\n  const router = await createRouter(ssrContext, config, { store })\n\n  // Create Root instance\n\n  // here we inject the router and store to all child components,\n  // making them available everywhere as `this.$router` and `this.$store`.\n  const app = {\n    head: {\"titleTemplate\":\"%s - Nuxt2Test\",\"title\":\"Nuxt2Test\",\"htmlAttrs\":{\"lang\":\"en\"},\"meta\":[{\"charset\":\"utf-8\"},{\"name\":\"viewport\",\"content\":\"width=device-width, initial-scale=1\"},{\"hid\":\"description\",\"name\":\"description\",\"content\":\"this is my test description.\"},{\"name\":\"format-detection\",\"content\":\"telephone=no\"}],\"link\":[{\"rel\":\"icon\",\"type\":\"image\\u002Fx-icon\",\"href\":\"\\u002Ffavicon.ico\"}],\"style\":[],\"script\":[]},\n\n    router,\n    nuxt: {\n      defaultTransition,\n      transitions: [defaultTransition],\n      setTransitions (transitions) {\n        if (!Array.isArray(transitions)) {\n          transitions = [transitions]\n        }\n        transitions = transitions.map((transition) => {\n          if (!transition) {\n            transition = defaultTransition\n          } else if (typeof transition === 'string') {\n            transition = Object.assign({}, defaultTransition, { name: transition })\n          } else {\n            transition = Object.assign({}, defaultTransition, transition)\n          }\n          return transition\n        })\n        this.$options.nuxt.transitions = transitions\n        return transitions\n      },\n\n      err: null,\n      dateErr: null,\n      error (err) {\n        err = err || null\n        app.context._errored = Boolean(err)\n        err = err ? normalizeError(err) : null\n        let nuxt = app.nuxt // to work with @vue/composition-api, see https://github.com/nuxt/nuxt.js/issues/6517#issuecomment-573280207\n        if (this) {\n          nuxt = this.nuxt || this.$options.nuxt\n        }\n        nuxt.dateErr = Date.now()\n        nuxt.err = err\n        // Used in src/server.js\n        if (ssrContext) {\n          ssrContext.nuxt.error = err\n        }\n        return err\n      }\n    },\n    ...App\n  }\n\n  const next = ssrContext ? ssrContext.next : location => app.router.push(location)\n  // Resolve route\n  let route\n  if (ssrContext) {\n    route = router.resolve(ssrContext.url).route\n  } else {\n    const path = getLocation(router.options.base, router.options.mode)\n    route = router.resolve(path).route\n  }\n\n  // Set context to app.context\n  await setContext(app, {\n    route,\n    next,\n    error: app.nuxt.error.bind(app),\n    payload: ssrContext ? ssrContext.payload : undefined,\n    req: ssrContext ? ssrContext.req : undefined,\n    res: ssrContext ? ssrContext.res : undefined,\n    beforeRenderFns: ssrContext ? ssrContext.beforeRenderFns : undefined,\n    beforeSerializeFns: ssrContext ? ssrContext.beforeSerializeFns : undefined,\n    ssrContext\n  })\n\n  function inject(key, value) {\n    if (!key) {\n      throw new Error('inject(key, value) has no key provided')\n    }\n    if (value === undefined) {\n      throw new Error(`inject('${key}', value) has no value provided`)\n    }\n\n    key = '$' + key\n    // Add into app\n    app[key] = value\n    // Add into context\n    if (!app.context[key]) {\n      app.context[key] = value\n    }\n\n    // Check if plugin not already installed\n    const installKey = '__nuxt_' + key + '_installed__'\n    if (Vue[installKey]) {\n      return\n    }\n    Vue[installKey] = true\n    // Call Vue.use() to install the plugin into vm\n    Vue.use(() => {\n      if (!Object.prototype.hasOwnProperty.call(Vue.prototype, key)) {\n        Object.defineProperty(Vue.prototype, key, {\n          get () {\n            return this.$root.$options[key]\n          }\n        })\n      }\n    })\n  }\n\n  // Inject runtime config as $config\n  inject('config', config)\n\n  // Add enablePreview(previewData = {}) in context for plugins\n  if (process.static && process.client) {\n    app.context.enablePreview = function (previewData = {}) {\n      app.previewData = Object.assign({}, previewData)\n      inject('preview', previewData)\n    }\n  }\n  // Plugin execution\n\n  if (typeof nuxt_plugin_plugin_0f208ee6 === 'function') {\n    await nuxt_plugin_plugin_0f208ee6(app.context, inject)\n  }\n\n  if (typeof nuxt_plugin_plugin_7416d2f2 === 'function') {\n    await nuxt_plugin_plugin_7416d2f2(app.context, inject)\n  }\n\n  if (typeof nuxt_plugin_pluginutils_828c0784 === 'function') {\n    await nuxt_plugin_pluginutils_828c0784(app.context, inject)\n  }\n\n  if (typeof nuxt_plugin_pluginrouting_a3a71bee === 'function') {\n    await nuxt_plugin_pluginrouting_a3a71bee(app.context, inject)\n  }\n\n  if (typeof nuxt_plugin_pluginmain_ac3843f4 === 'function') {\n    await nuxt_plugin_pluginmain_ac3843f4(app.context, inject)\n  }\n\n  if (typeof nuxt_plugin_axios_2675d830 === 'function') {\n    await nuxt_plugin_axios_2675d830(app.context, inject)\n  }\n\n  if (typeof nuxt_plugin_image_117cd52b === 'function') {\n    await nuxt_plugin_image_117cd52b(app.context, inject)\n  }\n\n  // Lock enablePreview in context\n  if (process.static && process.client) {\n    app.context.enablePreview = function () {\n      console.warn('You cannot call enablePreview() outside a plugin.')\n    }\n  }\n\n  // Wait for async component to be resolved first\n  await new Promise((resolve, reject) => {\n    // Ignore 404s rather than blindly replacing URL in browser\n    if (process.client) {\n      const { route } = router.resolve(app.context.route.fullPath)\n      if (!route.matched.length) {\n        return resolve()\n      }\n    }\n    router.replace(app.context.route.fullPath, resolve, (err) => {\n      // https://github.com/vuejs/vue-router/blob/v3.4.3/src/util/errors.js\n      if (!err._isRouter) return reject(err)\n      if (err.type !== 2 /* NavigationFailureType.redirected */) return resolve()\n\n      // navigated to a different route in router guard\n      const unregister = router.afterEach(async (to, from) => {\n        if (process.server && ssrContext && ssrContext.url) {\n          ssrContext.url = to.fullPath\n        }\n        app.context.route = await getRouteData(to)\n        app.context.params = to.params || {}\n        app.context.query = to.query || {}\n        unregister()\n        resolve()\n      })\n    })\n  })\n\n  return {\n    app,\n    router\n  }\n}\n\nexport { createApp, NuxtError }\n","import Vue from 'vue'\n\nexport default {\n  name: 'NuxtLink',\n  extends: Vue.component('RouterLink'),\n  props: {\n    prefetch: {\n      type: Boolean,\n      default: true\n    },\n    noPrefetch: {\n      type: Boolean,\n      default: false\n    }\n  }\n}\n","import Vue from 'vue'\nimport { joinURL, normalizeURL, withQuery } from 'ufo'\nimport fetch from 'node-fetch-native'\nimport middleware from './middleware.js'\nimport {\n   applyAsyncData,\n   middlewareSeries,\n   sanitizeComponent,\n  getMatchedComponents,\n  promisify\n} from './utils.js'\n  import fetchMixin from './mixins/fetch.server'\nimport { createApp, NuxtError  } from './index.js'\nimport NuxtLink from './components/nuxt-link.server.js' // should be included after ./index.js\n\n  // Update serverPrefetch strategy\n  Vue.config.optionMergeStrategies.serverPrefetch = Vue.config.optionMergeStrategies.created\n\n  // Fetch mixin\n  if (!Vue.__nuxt__fetch__mixin__) {\n    Vue.mixin(fetchMixin)\n    Vue.__nuxt__fetch__mixin__ = true\n  }\n\n      // Component: <NuxtLink>\n      Vue.component(NuxtLink.name, NuxtLink)\n       Vue.component('NLink', NuxtLink)\n\nif (!global.fetch) { global.fetch = fetch }\n\nconst noopApp = () => new Vue({ render: h => h('div', { domProps: { id: '__nuxt' } }) })\n\nconst createNext = ssrContext => (opts) => {\n  // If static target, render on client-side\n  ssrContext.redirected = opts\n  if (ssrContext.target === 'static' || !ssrContext.res) {\n    ssrContext.nuxt.serverRendered = false\n    return\n  }\n  let fullPath = withQuery(opts.path, opts.query)\n  const $config = ssrContext.nuxt.config || {}\n  const routerBase = ($config._app && $config._app.basePath) || '/'\n  if (!fullPath.startsWith('http') && (routerBase !== '/' && !fullPath.startsWith(routerBase))) {\n    fullPath = joinURL(routerBase, fullPath)\n  }\n  // Avoid loop redirect\n  if (decodeURI(fullPath) === decodeURI(ssrContext.url)) {\n    ssrContext.redirected = false\n    return\n  }\n  ssrContext.res.writeHead(opts.status, {\n    Location: normalizeURL(fullPath)\n  })\n  ssrContext.res.end()\n}\n\n// This exported function will be called by `bundleRenderer`.\n// This is where we perform data-prefetching to determine the\n// state of our application before actually rendering it.\n// Since data fetching is async, this function is expected to\n// return a Promise that resolves to the app instance.\nexport default async (ssrContext) => {\n  // Create ssrContext.next for simulate next() of beforeEach() when wanted to redirect\n  ssrContext.redirected = false\n  ssrContext.next = createNext(ssrContext)\n  // Used for beforeNuxtRender({ Components, nuxtState })\n  ssrContext.beforeRenderFns = []\n  // for beforeSerialize(nuxtState)\n  ssrContext.beforeSerializeFns = []\n  // Nuxt object (window.{{globals.context}}, defaults to window.__NUXT__)\n  ssrContext.nuxt = {  layout: 'default',  data: [],  fetch: { },  error: null , serverRendered: true, routePath: ''\n}\n\n  ssrContext.fetchCounters = { }\n\n  // Remove query from url is static target\n\n  // Public runtime config\n  ssrContext.nuxt.config = ssrContext.runtimeConfig.public\nif (ssrContext.nuxt.config._app) {\n  __webpack_public_path__ = joinURL(ssrContext.nuxt.config._app.cdnURL, ssrContext.nuxt.config._app.assetsPath)\n}\n// Create the app definition and the instance (created for each request)\nconst { app, router } = await createApp(ssrContext, ssrContext.runtimeConfig.private)\nconst _app = new Vue(app)\n// Add ssr route path to nuxt context so we can account for page navigation between ssr and csr\nssrContext.nuxt.routePath = app.context.route.path\n\n    // Add meta infos (used in renderer.js)\n    ssrContext.meta = _app.$meta()\n\n  // Keep asyncData for each matched component in ssrContext (used in app/utils.js via this.$ssrContext)\n  ssrContext.asyncData = { }\n\n  const beforeRender = async () => {\n  // Call beforeNuxtRender() methods\n  await Promise.all(ssrContext.beforeRenderFns.map(fn => promisify(fn, { Components, nuxtState: ssrContext.nuxt })))\n\n  ssrContext.rendered = () => {\n    // Call beforeSerialize() hooks\n    ssrContext.beforeSerializeFns.forEach(fn => fn(ssrContext.nuxt))\n    }\n}\n\nconst renderErrorPage = async () => {\n  // Don't server-render the page in static target\n  if (ssrContext.target === 'static') {\n    ssrContext.nuxt.serverRendered = false\n  }\n\n    // Load layout for error page\n    const layout = (NuxtError.options || NuxtError).layout\n    const errLayout = typeof layout === 'function' ? layout.call(NuxtError, app.context) : layout\n    ssrContext.nuxt.layout = errLayout || 'default'\n    await _app.loadLayout(errLayout)\n    _app.setLayout(errLayout)\n\n        await beforeRender()\n  return _app\n}\nconst render404Page = () => {\n  app.context.error({ statusCode: 404, path: ssrContext.url, message: 'This page could not be found' })\n  return renderErrorPage()\n}\n\n  // Components are already resolved by setContext -> getRouteData (app/utils.js)\n  const Components = getMatchedComponents(app.context.route)\n\n  /*\n  ** Call global middleware (nuxt.config.js)\n  */\n  let midd = [\"nuxti18n\"]\n    midd = midd.map((name) => {\n      if (typeof name === 'function') {\n        return name\n      }\n      if (typeof middleware[name] !== 'function') {\n        app.context.error({ statusCode: 500, message: 'Unknown middleware ' + name })\n      }\n      return middleware[name]\n    })\n  await middlewareSeries(midd, app.context)\n  // ...If there is a redirect or an error, stop the process\n  if (ssrContext.redirected) {\n    return noopApp()\n  }\n  if (ssrContext.nuxt.error) {\n    return renderErrorPage()\n  }\n\n  /*\n  ** Set layout\n  */\n  let layout = Components.length ? Components[0].options.layout : NuxtError.layout\n  if (typeof layout === 'function') {\n    layout = layout(app.context)\n  }\n  await _app.loadLayout(layout)\n  if (ssrContext.nuxt.error) {\n    return renderErrorPage()\n  }\n  layout = _app.setLayout(layout)\n  ssrContext.nuxt.layout = _app.layoutName\n\n  /*\n  ** Call middleware (layout + pages)\n  */\n  midd =[]\n\n      layout = sanitizeComponent(layout)\n      if (layout.options.middleware) {\n        midd = midd.concat(layout.options.middleware)\n      }\n\n    Components.forEach((Component) => {\n      if (Component.options.middleware) {\n        midd = midd.concat(Component.options.middleware)\n      }\n    })\n  midd = midd.map((name) => {\n    if (typeof name === 'function') {\n      return name\n    }\n    if (typeof middleware[name] !== 'function') {\n      app.context.error({ statusCode: 500, message: 'Unknown middleware ' + name })\n    }\n    return middleware[name]\n  })\n  await middlewareSeries(midd, app.context)\n  // ...If there is a redirect or an error, stop the process\n  if (ssrContext.redirected) {\n    return noopApp()\n  }\n  if (ssrContext.nuxt.error) {\n    return renderErrorPage()\n  }\n\n  /*\n  ** Call .validate()\n  */\n  let isValid = true\n  try {\n    for (const Component of Components) {\n      if (typeof Component.options.validate !== 'function') {\n        continue\n      }\n\n      isValid = await Component.options.validate(app.context)\n\n      if (!isValid) {\n        break\n      }\n    }\n  } catch (validationError) {\n    // ...If .validate() threw an error\n    app.context.error({\n      statusCode: validationError.statusCode || '500',\n      message: validationError.message\n    })\n    return renderErrorPage()\n  }\n\n  // ...If .validate() returned false\n  if (!isValid) {\n    // Render a 404 error page\n    return render404Page()\n  }\n\n  // If no Components found, returns 404\n  if (!Components.length) {\n  return render404Page()\n}\n\n  // Call asyncData & fetch hooks on components matched by the route.\n  const asyncDatas = await Promise.all(Components.map((Component) => {\n  const promises = []\n\n    // Call asyncData(context)\n    if (Component.options.asyncData && typeof Component.options.asyncData === 'function') {\n        const promise = promisify(Component.options.asyncData, app.context)\n        promise.then((asyncDataResult) => {\n          ssrContext.asyncData[Component.cid] = asyncDataResult\n          applyAsyncData(Component)\n          return asyncDataResult\n        })\n        promises.push(promise)\n      } else {\n        promises.push(null)\n      }\n\n    // Call fetch(context)\n    if (Component.options.fetch && Component.options.fetch.length) {\n      promises.push(Component.options.fetch(app.context))\n    } else {\n      promises.push(null)\n    }\n\n    return Promise.all(promises)\n}))\n\n      // datas are the first row of each\n      ssrContext.nuxt.data = asyncDatas.map(r => r[0] || {})\n\n  // ...If there is a redirect or an error, stop the process\n  if (ssrContext.redirected) {\n  return noopApp()\n}\nif (ssrContext.nuxt.error) {\n  return renderErrorPage()\n}\n\n// Call beforeNuxtRender methods & add store state\nawait beforeRender()\n\nreturn _app\n}\n","module.exports = require(\"devalue\");","module.exports = require(\"image-meta\");"],"mappings":";;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACnHA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;ACxCA;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA,eAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA,iBAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA,eAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;ACrOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AClgBA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AChfA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/FA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AChfA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;;ACAA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;AC9DA;AACA;AACA;AACA;;;;;;;ACHA;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;ACrOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;ACjDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACrCA;AAAA;AAAA;AAAA;;;;;;;ACAA;AACA;AACA;AACA;;;;;;;ACHA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;ACAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AAEA;;ACFA;AACA;AACA;AACA;AACA;AACA,aAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAEA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;;AClnBA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;;;;;;AChEA;AAEA,aAgBA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjFA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,iBAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAmBA;;AC3GA;AAAA;AAAA;AAAA;AACA;AACA;;;;;AADA;AACA;AACA;;ACHA;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrBA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzJA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvBA;AAAA;AAAA;AAAA;AACA;AACA;;;;;AADA;AACA;AACA;;ACHA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAKA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA,iBAQA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA,mBASA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AC3MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACjCA;AACA;AAEA;AACA;AACA;AACA;;ACNA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAHA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;;ACjHA;AAEA;AAEA;AACA;AACA;AAEA;AACA;;;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA5BA;AA8BA;;;;;ACzEA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AAVA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;AADA;AAHA;AAOA;AACA;AADA;AAGA;AACA;AACA;AAFA;AAIA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AADA;AASA;AACA;AACA;AADA;AADA;AA/DA;;ACAA;AACA;AACA;AAEA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAJA;AAJA;AAWA;AACA;AACA;AACA;AAHA;AAKA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAJA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AALA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AAVA;AAXA;AAxBA;;ACbA;AAKA;AAKA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAFA;AADA;AAOA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAhBA;AAkBA;AAGA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AAMA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAEA;AAMA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AAEA;AAKA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjBA;AAoBA;;;AAGA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAAA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AADA;AAFA;AAMA;AAEA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAFA;AAIA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AAOA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAGA;AACA;AAAA;AAIA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;;ACxfA;AAAA;AACA;AAGA;AADA;AAHA;;ACNA;AACA;AACA;AAEA;AACA;AAIA;AAMA;AAGA;AAIA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAFA;AAKA;AACA;AACA;AAEA;AAIA;AA3BA;AACA;;AChBA;AACA;AAKA;AAAA;;AAGA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAPA;AA+BA;AArBA;AAKA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AA/CA;AACA;;ACPA;AACA;AAMA;AAuDA;AACA;AACA;AArDA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AAEA;AAGA;AACA;AAAA;AAQA;AAKA;AACA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;AAGA;AAAA;AAEA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AALA;AAQA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAIA;AAEA;AACA;AACA;AACA;AAAA;AAIA;AApLA;AACA;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACzBA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AChDA;AACA;AACA;AAEA;AACA;AAUA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;AAQA;AAEA;AACA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAPA;AACA;;AClFA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjCA;AAoCA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjCA;AAoCA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjCA;AAoCA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjCA;AAoCA;;ACpCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAjCA;AAoCA;;ACpCA;AAEA;AAIA;AAEA;AACA;AACA;AACA;AACA;AADA;AAFA;AAMA;AAEA;AACA;AAEA;;ACtBA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AANA;;ACPA;AACA;AACA;AAEA;AACA;AAMA;AAEA;AASA;AACA;AAEA;AACA;AACA;AACA;AAHA;AAMA;AACA;AACA;AAIA;AAxBA;AACA;;ACdA;AACA;AACA;AAEA;AACA;AASA;AACA;AAEA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAWA;AACA;AAPA;AASA;AACA;AACA;AACA;AAHA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AA/CA;AACA;;ACvCA;AACA;AAEA;AACA;AAMA;AACA;AAMA;AACA;AAMA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;ACjEA;AACA;AACA;AACA;AAkBA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;;;;AAIA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;;;;AAIA;AACA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAMA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAJA;AAMA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;AAKA;AACA;AAAA;AACA;AACA;AAEA;AACA;;ACtPA;AACA;AACA;AAMA;AAMA;AACA;AACA;AAEA;AAKA;AAEA;AACA;AACA;AACA;AAKA;;ACnCA;AACA;AACA;AACA;AAMA;AAKA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AADA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AChJA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AASA;AAmBA;AACA;AAjBA;AAUA;AAEA;AAEA;AAKA;AACA;AACA;AACA;AACA;AAJA;AAOA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAFA;AAIA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAAA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAAA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAIA;AAEA;AAIA;AAGA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AAMA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAJA;AADA;AAQA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAKA;AAGA;AACA;AAAA;AACA;AACA;AA7QA;AACA;;ACnBA;AACA;AAaA;AAEA;AAqBA;AAVA;AACA;AADA;AAIA;AAEA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AA5DA;AACA;AAEA;AAEA;AAEA;AACA;AADA;;ACvBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;;ACAA;AACA;AAEA;AAEA;AAGA;AACA;AAEA;AAEA;AACA;AACA;;;;;;;;;;;;;;;ACfA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AACA,uBAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACnMA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACtQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;ACpDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA,iBAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AAAA;AAEA,eAKA;AACA;;;;;;;;;;AC3XA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;AChMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAyBA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACrLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;ACFA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ADzDA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAIA;AACA;AACA;;AEtFA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;AADA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAEA;AACA;AACA;;ACrFA;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AClBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC9BA;AACA;AACA;AACA;AACA;AACA;;ACLA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAAA;AAAA;AACA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA,eAKA;AAEA;AACA;;AC7CA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA,iBAEA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA,eAIA;AACA;AACA;AACA;AACA;AACA,iBAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;AC7PA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACfA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAAA;AAEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;ACnRA;;;;;;ACAA;;;A","sourceRoot":""}